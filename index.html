<!DOCTYPE html>
<html>
    <head>
        <title>Type classes from the ground up</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <link rel="stylesheet" type="text/css" href="css/style.css"/>
    </head>
    <body>
        <textarea id="source">
class: center, middle

# Type classes from the ground up

Nicolas Rinaudo • [@NicolasRinaudo] • [Besedo]

---

class: center, middle

# Parsing CSV

---

## CSV data

```csv
1,2,3
4,5,6
7,8,9
```

```scala
type Cell = String
type Row  = List[Cell]
type Csv  = List[Row]
```

---

## CSV data

```csv
&#x200B;`1,2,3`
&#x200B;`4,5,6`
&#x200B;`7,8,9`
```

```scala
type Cell = String
type Row  = List[Cell]
*type Csv  = List[Row]
```

---

## CSV data

```csv
&#x200B;`1`,`2`,`3`
4,5,6
7,8,9
```

```scala
type Cell = String
*type Row  = List[Cell]
type Csv  = List[Row]
```

---

## CSV data

```csv
&#x200B;`1`,2,3
4,5,6
7,8,9
```

```scala
*type Cell = String
type Row  = List[Cell]
type Csv  = List[Row]
```

---

## Parsing CSV

```csv
1,2,3
4,5,6
7,8,9
```

```scala
def parseCsv(data: String) = ???
```

---

## Parsing CSV

```csv
*1,2,3
*4,5,6
*7,8,9
```

```scala
def parseCsv(`data: String`) = ???
```

---

## Parsing CSV

```csv
&#x200B;`1,2,3`
&#x200B;`4,5,6`
&#x200B;`7,8,9`
```

```scala
def parseCsv(data: String) =
  data.
    split("\n").toList
```

---

## Parsing CSV

```csv
&#x200B;`1,2,3`
&#x200B;`4,5,6`
&#x200B;`7,8,9`
```

```scala
def parseCsv(data: String) =
  data.
    `split("\n")`.toList
```

---

## Parsing CSV

```csv
&#x200B;`1`,`2`,`3`
&#x200B;`4`,`5`,`6`
&#x200B;`7`,`8`,`9`
```

```scala
def parseCsv(data: String): Csv =
  data.
    split("\n").toList.
    map(_.split(",").toList)
```

---

## Parsing CSV

```csv
&#x200B;`1`,`2`,`3`
&#x200B;`4`,`5`,`6`
&#x200B;`7`,`8`,`9`
```

```scala
def parseCsv(data: String): Csv =
  data.
    split("\n").toList.
    map(_.`split(",")`.toList)
```

---

## Parsing CSV

```csv
&#x200B;`1`,`2`,`3`
&#x200B;`4`,`5`,`6`
&#x200B;`7`,`8`,`9`
```

```scala
def parseCsv(data: String): `Csv` =
  data.
    split("\n").toList.
    map(_.split(",").toList)
```

---

## Parsing CSV


```scala
val input = """1,2,3
              |4,5,6
              |7,8,9"""
```

--

```scala
parseCsv(input)
// res0: Csv = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

---

class: center, middle

# Decoding CSV

---

## Decoding to `Int`

```csv
1,2,3
4,5,6
7,8,9
```

```scala
parseCsv(input).
  map(_.map(_.toInt))
```

---

## Decoding to `Int`

```csv
&#x200B;`1`,`2`,`3`
&#x200B;`4`,`5`,`6`
&#x200B;`7`,`8`,`9`
```

```scala
&#x200B;`parseCsv(input)`.
  map(_.map(_.toInt))
```

---

## Decoding to `Int`

```csv
&#x200B;`1`,`2`,`3`
4,5,6
7,8,9
```

```scala
parseCsv(input).
  `map`(_.map(_.toInt))
```

---

## Decoding to `Int`

```csv
&#x200B;`1`,2,3
4,5,6
7,8,9
```

```scala
parseCsv(input).
  map(_.`map`(_.toInt))
```

---

## Decoding to `Int`

```csv
&#x200B;`1`,2,3
4,5,6
7,8,9
```

```scala
parseCsv(input).
  map(_.map(_.`toInt`))
```

---

## Decoding to `Int`

```csv
1,2,3
4,5,6
7,8,9
```

```scala
parseCsv(input).
  map(_.map(_.toInt))
// res1: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input: String
): List[List[Int]] =
  parseCsv(input).
    map(_.map(_.toInt))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  `input: String`
): List[List[Int]] =
  parseCsv(input).
    map(_.map(_.toInt))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input: String
): `List[List[Int]]` =
  parseCsv(input).
    map(_.map(_.toInt))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input: String
): List[List[Int]] =
* parseCsv(input).
*   map(_.map(_.toInt))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input: String
): List[List[Int]] =
  parseCsv(input).
    map(_.map(`_.toInt`))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input     : String,
  decodeCell: Cell => Int
): List[List[Int]] =
  parseCsv(input).
    map(_.map(decodeCell))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input     : String,
  `decodeCell: Cell => Int`
): List[List[Int]] =
  parseCsv(input).
    map(_.map(decodeCell))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input     : String,
  decodeCell: Cell => Int
): List[List[Int]] =
  parseCsv(input).
    map(_.map(`decodeCell`))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input     : String,
  decodeCell: Cell => `Int`
): List[List[`Int`]] =
  parseCsv(input).
    map(_.map(decodeCell))
```

---

## Generic decoding

```scala
def decodeCsv[A](
  input     : String,
  decodeCell: Cell => A
): List[List[A]] =
  parseCsv(input).
    map(_.map(decodeCell))
```

---

## Generic decoding

```scala
def decodeCsv[`A`](
  input     : String,
  decodeCell: Cell => `A`
): List[List[`A`]] =
  parseCsv(input).
    map(_.map(decodeCell))
```

---

## Generic decoding

```scala
decodeCsv(input, _.toInt)
```

---

## Generic decoding

```scala
decodeCsv(input, `_.toInt`)
```

---

## Generic decoding

```scala
decodeCsv(input, _.toInt)
// res2: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

---

## Generic decoding

```scala
decodeCsv(input, _.toFloat)
```

---

## Generic decoding

```scala
decodeCsv(input, `_.toFloat`)
```

---

## Generic decoding

```scala
decodeCsv(input, _.toFloat)
// res3: List[List[Float]] = List(List(1.0, 2.0, 3.0), List(4.0, 5.0, 6.0), List(7.0, 8.0, 9.0))
```

---

## Implicit resolution

> When a function expects a parameter of type `T` _and_ that parameter is marked as `implicit` _and_ there exists a
> value of type `T` marked as `implicit` in scope, then the compiler will use that value if the parameter is unspecified.

```scala
implicit val defaultInt: Int = 2

def printInt(implicit i: Int): Unit = println(i)
```

```scala
printInt
```

---

## Implicit resolution

> When .highlight[a function expects a parameter of type `T`] _and_ that parameter is marked as `implicit` _and_ there exists a
> value of type `T` marked as `implicit` in scope, then the compiler will use that value if the parameter is unspecified.

```scala
implicit val defaultInt: Int = 2

def printInt(implicit `i: Int`): Unit = println(i)
```

```scala
printInt
```

---

## Implicit resolution

> When a function expects a parameter of type `T` _and_ that parameter is .highlight[marked as `implicit`] _and_ there exists a
> value of type `T` marked as `implicit` in scope, then the compiler will use that value if the parameter is unspecified.

```scala
implicit val defaultInt: Int = 2

def printInt(`implicit` i: Int): Unit = println(i)
```

```scala
printInt
```

---

## Implicit resolution

> When a function expects a parameter of type `T` _and_ that parameter is marked as `implicit` _and_ there exists a
> .highlight[value of type `T`] marked as `implicit` in scope, then the compiler will use that value if the parameter is unspecified.

```scala
implicit `val defaultInt: Int` = 2

def printInt(implicit i: Int): Unit = println(i)
```

```scala
printInt
```

---

## Implicit resolution

> When a function expects a parameter of type `T` _and_ that parameter is marked as `implicit` _and_ there exists a
> value of type `T` marked as .highlight[`implicit`] in scope, then the compiler will use that value if the parameter is unspecified.

```scala
&#x200B;`implicit` val defaultInt: Int = 2

def printInt(implicit i: Int): Unit = println(i)
```

```scala
printInt
```

---

## Implicit resolution

> When a function expects a parameter of type `T` _and_ that parameter is marked as `implicit` _and_ there exists a
> value of type `T` marked as `implicit` in scope, then the compiler will use that value .highlight[if the parameter is unspecified].

```scala
implicit val defaultInt: Int = 2

def printInt(implicit i: Int): Unit = println(i)
```

```scala
printInt`            `
```

---

## Implicit resolution

> When a function expects a parameter of type `T` _and_ that parameter is marked as `implicit` _and_ there exists a
> value of type `T` marked as `implicit` in scope, then .highlight[the compiler will use that value] if the parameter is unspecified.

```scala
implicit val defaultInt: Int = 2

def printInt(implicit i: Int): Unit = println(i)
```

```scala
printInt`(defaultInt)`
```

---

## Implicit resolution

> When a function expects a parameter of type `T` _and_ that parameter is marked as `implicit` _and_ there exists a
> value of type `T` marked as `implicit` in scope, then the compiler will use that value if the parameter is unspecified.

```scala
implicit val defaultInt: Int = 2

def printInt(implicit i: Int): Unit = println(i)
```

```scala
printInt
// 2
```

---

## Decoding CSV with implicits

```scala
def decodeCsv[A]
  (input: String)
  (implicit decodeCell: Cell => A)
 : List[List[A]] =
  parseCsv(input).
    map(_.map(decodeCell))

```

---

## Decoding CSV with implicits

```scala
def decodeCsv[A]
  (input: String)
  (`implicit decodeCell: Cell => A`)
 : List[List[A]] =
  parseCsv(input).
    map(_.map(decodeCell))
```

---

## Decoding CSV with implicits

```scala
implicit val strToInt: Cell => Int =
  Integer.parseInt
```

---

## Decoding CSV with implicits

```scala
&#x200B;`implicit` val strToInt: `Cell => Int` =
  Integer.parseInt
```

---

## Decoding CSV with implicits

```scala
decodeCsv[Int](input)
```

---

## Decoding CSV with implicits

```scala
decodeCsv[`Int`](input)
```

---

## Decoding CSV with implicits

```scala
decodeCsv[Int](input)`    `
```

---

## Decoding CSV with implicits

```scala
decodeCsv[Int](input)
// res6: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

---

## The dangers of implicits

> When the compiler finds a type `S` where it expects a type `T`, but there exists an implicit `S => T`
> in scope, it will be applied silently.

```scala
implicit val strToInt: String => Int =
  Integer.parseInt

def add1(i: Int): Int = i + 1
```

```scala
add1("123")
```

---

## The dangers of implicits

> When .highlight[the compiler finds a type `S`] where it expects a type `T`, but there exists an implicit `S => T`
> in scope, it will be applied silently.

```scala
implicit val strToInt: String => Int =
  Integer.parseInt

def add1(i: Int): Int = i + 1
```

```scala
add1(`"123"`)
```

---

## The dangers of implicits

> When the compiler finds a type `S` where .highlight[it expects a type `T`], but there exists an implicit `S => T`
> in scope, it will be applied silently.

```scala
implicit val strToInt: String => Int =
  Integer.parseInt

def add1(`i: Int`): Int = i + 1
```

```scala
add1("123")
```

---

## The dangers of implicits

> When the compiler finds a type `S` where it expects a type `T`, but .highlight[there exists an implicit `S => T`]
> in scope, it will be applied silently.

```scala
&#x200B;`implicit` val strToInt: `String => Int` =
  Integer.parseInt

def add1(i: Int): Int = i + 1
```

```scala
add1("123")
```

---

## The dangers of implicits

> When the compiler finds a type `S` where it expects a type `T`, but there exists an implicit `S => T`
> in scope, .highlight[it will be applied silently].

```scala
implicit val strToInt: String => Int =
  Integer.parseInt

def add1(i: Int): Int = i + 1
```

```scala
add1(`strToInt("123")`)
```

---

## The dangers of implicits

> When the compiler finds a type `S` where it expects a type `T`, but there exists an implicit `S => T`
> in scope, it will be applied silently.

```scala
implicit val strToInt: String => Int =
  Integer.parseInt

def add1(i: Int): Int = i + 1
```

```scala
add1("123")
// res8: Int = 124
```

---

## Using a decoder type

```scala
trait CellDecoder[T] {
  def decode(cell: Cell): T
}
```

---

## Using a decoder type

```scala
trait `CellDecoder[T]` {
  def decode(cell: Cell): T
}
```

---

## Using a decoder type

```scala
trait CellDecoder[T] {
  `def decode(cell: Cell): T`
}
```

---

## Using a decoder type

```scala
trait CellDecoder[T] {
  def decode(`cell: Cell`): T
}
```

---

## Using a decoder type

```scala
trait CellDecoder[T] {
  def decode(cell: Cell): `T`
}
```

---

## Using a decoder type

```scala
object CellDecoder {
  def from[T](
    f: Cell => T
  ) = new CellDecoder[T] {
    override def decode(cell: Cell) = f(cell)
  }
}
```

---

## Using a decoder type

```scala
&#x200B;`object CellDecoder` {
  def from[T](
    f: Cell => T
  ) = new CellDecoder[T] {
    override def decode(cell: Cell) = f(cell)
  }
}
```

---

## Using a decoder type

```scala
object CellDecoder {
  `def from[T]`(
    f: Cell => T
  ) = `new CellDecoder[T]` {
    override def decode(cell: Cell) = f(cell)
  }
}
```

---

## Using a decoder type

```scala
object CellDecoder {
  def from[T](
    `f: Cell => T`
  ) = new CellDecoder[T] {
    override `def decode(cell: Cell) = f(cell)`
  }
}
```

---

## Using a decoder type

```scala
implicit val intCellDecoder: CellDecoder[Int] =
  CellDecoder.from(_.toInt)

implicit val floatCellDecoder: CellDecoder[Float] =
  CellDecoder.from(_.toFloat)

implicit val stringCellDecoder: CellDecoder[String] =
  CellDecoder.from(identity)

implicit val booleanCellDecoder: CellDecoder[Boolean] =
  CellDecoder.from(_.toBoolean)
```

---

## Using a decoder type

```scala
implicit val intCellDecoder: `CellDecoder[Int]` =
  CellDecoder.from(`_.toInt`)

implicit val floatCellDecoder: CellDecoder[Float] =
  CellDecoder.from(_.toFloat)

implicit val stringCellDecoder: CellDecoder[String] =
  CellDecoder.from(identity)

implicit val booleanCellDecoder: CellDecoder[Boolean] =
  CellDecoder.from(_.toBoolean)
```

---

## Using a decoder type

```scala
implicit val intCellDecoder: CellDecoder[Int] =
  CellDecoder.from(_.toInt)

implicit val floatCellDecoder: `CellDecoder[Float]` =
  CellDecoder.from(`_.toFloat`)

implicit val stringCellDecoder: CellDecoder[String] =
  CellDecoder.from(identity)

implicit val booleanCellDecoder: CellDecoder[Boolean] =
  CellDecoder.from(_.toBoolean)
```

---

## Using a decoder type

```scala
implicit val intCellDecoder: CellDecoder[Int] =
  CellDecoder.from(_.toInt)

implicit val floatCellDecoder: CellDecoder[Float] =
  CellDecoder.from(_.toFloat)

implicit val stringCellDecoder: `CellDecoder[String]` =
  CellDecoder.from(`identity`)

implicit val booleanCellDecoder: CellDecoder[Boolean] =
  CellDecoder.from(_.toBoolean)
```

---

## Using a decoder type

```scala
implicit val intCellDecoder: CellDecoder[Int] =
  CellDecoder.from(_.toInt)

implicit val floatCellDecoder: CellDecoder[Float] =
  CellDecoder.from(_.toFloat)

implicit val stringCellDecoder: CellDecoder[String] =
  CellDecoder.from(identity)

implicit val booleanCellDecoder: `CellDecoder[Boolean]` =
  CellDecoder.from(`_.toBoolean`)
```

---

## Type class backed decoder

```scala
def decodeCsv[A]
  (input: String)
  (implicit da: CellDecoder[A])
 : List[List[A]] =
  parseCsv(input).
    map(_.map(da.decode))
```

---

## Type class backed decoder

```scala
def decodeCsv[A]
  (input: String)
  (implicit `da: CellDecoder[A]`)
 : List[List[A]] =
  parseCsv(input).
    map(_.map(da.decode))
```

---

## Type class backed decoder

```scala
def decodeCsv[A]
  (input: String)
  (implicit da: CellDecoder[A])
 : List[List[A]] =
  parseCsv(input).
    map(_.map(`da.decode`))
```

---

## Type class backed decoder

```scala
decodeCsv[Int](input)
```

---

## Type class backed decoder

```scala
decodeCsv[`Int`](input)
```

---

## Type class backed decoder

```scala
decodeCsv[Int](input)`   `
```

---

## Type class backed decoder

```scala
decodeCsv[Int](input)
// res10: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

---

## Key takeaways

--
We have made `decodeCsv` polymorphic by using:

--
* parametric polymorphism.

--
* implicit resolution.

--

`CellDecoder` is known as a type class.

---

class: center, middle

# Implicit type class composition

---

## Heterogenous types

```csv
1997,Ford
2000,Mercury
```

---

## Heterogenous types

```csv
&#x200B;`1997`,Ford
&#x200B;`2000`,Mercury
```

---

## Heterogenous types

```csv
1997,`Ford`
2000,`Mercury`
```

---

## `RowDecoder` type class

```scala
trait RowDecoder[T] {
  def decode(row: Row): T
}
```

---

## `RowDecoder` type class

```scala
trait `RowDecoder[T]` {
  def decode(row: Row): T
}
```

---

## `RowDecoder` type class

```scala
trait RowDecoder[T] {
  `def decode(row: Row): T`
}
```

---

## `RowDecoder` type class

```scala
trait RowDecoder[T] {
  def decode(`row: Row`): T
}
```

---

## `RowDecoder` type class

```scala
trait RowDecoder[T] {
  def decode(row: Row): `T`
}
```

---

## `RowDecoder` type class

```scala
object RowDecoder {
  def from[T](
    f: Row => T
  ) = new RowDecoder[T] {
    override def decode(row: Row) = f(row)
  }
}
```

---

## `RowDecoder` type class

```scala
&#x200B;`object RowDecoder` {
  def from[T](
    f: Row => T
  ) = new RowDecoder[T] {
    override def decode(row: Row) = f(row)
  }
}
```

---

## `RowDecoder` type class

```scala
object RowDecoder {
  `def from[T]`(
    f: Row => T
  ) = `new RowDecoder[T]` {
    override def decode(row: Row) = f(row)
  }
}
```

---

## `RowDecoder` type class

```scala
object RowDecoder {
  def from[T](
    `f: Row => T`
  ) = new RowDecoder[T] {
    override `def decode(row: Row) = f(row)`
  }
}
```

---

## `RowDecoder` type class

```scala
def decodeCsv[A](input: String)
                (implicit da: RowDecoder[A]): List[A] =
  parseCsv(input).
    map(da.decode)
```

---

## `RowDecoder` type class

```scala
def decodeCsv[A](input: String)
                (implicit `da: RowDecoder[A]`): List[A] =
  parseCsv(input).
    map(da.decode)
```

---

## `RowDecoder` type class

```scala
def decodeCsv[A](input: String)
                (implicit da: RowDecoder[A]): List[A] =
  parseCsv(input).
    `map(da.decode)`
```

---

## `RowDecoder` type class

```scala
def decodeCsv[A](input: String)
                (implicit da: RowDecoder[A]): `List[A]` =
  parseCsv(input).
    map(da.decode)
```

---

## First attempt at decoding tuples

```scala
implicit val tupleDecoder = RowDecoder.from[(Int, String)] {
  row => (
    row(0).toInt,
    row(1)
  )
}
```

---

## First attempt at decoding tuples

```scala
&#x200B;`implicit` val tupleDecoder = `RowDecoder`.from[`(Int, String)`] {
  row => (
    row(0).toInt,
    row(1)
  )
}
```


---

## First attempt at decoding tuples

```scala
implicit val tupleDecoder = RowDecoder.from[(Int, String)] {
  `row` => (
    row(0).toInt,
    row(1)
  )
}
```

---

## First attempt at decoding tuples

```scala
implicit val tupleDecoder = RowDecoder.from[(Int, String)] {
  row => (
    `row(0).toInt`,
    row(1)
  )
}
```

---

## First attempt at decoding tuples

```scala
implicit val tupleDecoder = RowDecoder.from[(Int, String)] {
  row => (
    row(0).toInt,
    `row(1)`
  )
}
```

---

## First attempt at decoding tuples

```scala
implicit val tupleDecoder = RowDecoder.from[(Int, String)] {
  row => `(`
    row(0).toInt,
    row(1)
  `)`
}
```

---

## First attempt at decoding tuples

```scala
implicit val tupleDecoder = RowDecoder.from[(Int, String)] {
  row => (
    `row(0).toInt`,
    `row(1)`
  )
}
```


---

## Using `CellDecoder`, take 1


```scala
implicit val tupleDecoder = RowDecoder.from[(Int, String)] {
  row => (
    intCellDecoder.decode(row(0)),
    stringCellDecoder.decode(row(1))
  )
}
```

---

## Using `CellDecoder`, take 1


```scala
implicit val tupleDecoder = RowDecoder.from[(Int, String)] {
  row => (
    `intCellDecoder.decode(row(0))`,
    `stringCellDecoder.decode(row(1))`
  )
}
```

---

## Using `CellDecoder`, take 1


```scala
implicit `val` tupleDecoder = RowDecoder.from[(Int, String)] {
  row => (
    intCellDecoder.decode(row(0)),
    stringCellDecoder.decode(row(1))
  )
}
```

---

## Implicit resolution revisited

> When the compiler looks for an implicit value of type `T` and finds an implicit function that returns a `T` that
> it can call, it will use its return value.


```scala
implicit val defaultDouble: Double = 3.0

implicit def getFloat(implicit d: Double): Float = d.toFloat

def printFloat(implicit f: Float): Unit = println(f)
```

```scala
printFloat
```

---

## Implicit resolution revisited

> When the .highlight[compiler looks for an implicit value of type `T`] and finds an implicit function that returns a `T` that
> it can call, it will use its return value.


```scala
implicit val defaultDouble: Double = 3.0

implicit def getFloat(implicit d: Double): Float = d.toFloat

def printFloat(implicit f: Float): Unit = println(f)
```

```scala
printFloat`   `
```

---

## Implicit resolution revisited

> When the .highlight[compiler looks for an implicit value of type `T`] and finds an implicit function that returns a `T` that
> it can call, it will use its return value.


```scala
implicit val defaultDouble: Double = 3.0

implicit def getFloat(implicit d: Double): Float = d.toFloat

def printFloat(`implicit f: Float`): Unit = println(f)
```

```scala
printFloat
```

---

## Implicit resolution revisited

> When the compiler looks for an implicit value of type `T` and .highlight[finds an implicit function that returns a `T`] that
> it can call, it will use its return value.


```scala
implicit val defaultDouble: Double = 3.0

&#x200B;`implicit def getFloat`(implicit d: Double): `Float` = d.toFloat

def printFloat(implicit f: Float): Unit = println(f)
```

```scala
printFloat
```

---

## Implicit resolution revisited

> When the compiler looks for an implicit value of type `T` and finds an implicit function that returns a `T` that
> .highlight[it can call], it will use its return value.


```scala
implicit val defaultDouble: Double = 3.0

implicit def getFloat(`implicit d: Double`): Float = d.toFloat

def printFloat(implicit f: Float): Unit = println(f)
```

```scala
printFloat
```

---

## Implicit resolution revisited

> When the compiler looks for an implicit value of type `T` and finds an implicit function that returns a `T` that
> .highlight[it can call], it will use its return value.


```scala
&#x200B;`implicit val defaultDouble: Double` = 3.0

implicit def getFloat(implicit d: Double): Float = d.toFloat

def printFloat(implicit f: Float): Unit = println(f)
```

```scala
printFloat
```

---

## Implicit resolution revisited

> When the compiler looks for an implicit value of type `T` and finds an implicit function that returns a `T` that
> it can call, .highlight[it will use its return value].


```scala
implicit val defaultDouble: Double = 3.0

implicit def getFloat(implicit d: Double): Float = d.toFloat

def printFloat(implicit f: Float): Unit = println(f)
```

```scala
printFloat`(getFloat)`
```

---

## Implicit resolution revisited

> When the compiler looks for an implicit value of type `T` and finds an implicit function that returns a `T` that
> it can call, .highlight[it will use its return value].


```scala
implicit val defaultDouble: Double = 3.0

implicit def getFloat(implicit d: Double): Float = d.toFloat

def printFloat(implicit f: Float): Unit = println(f)
```

```scala
printFloat`(getFloat(defaultDouble))`
```

---

## Implicit resolution revisited

> When the compiler looks for an implicit value of type `T` and finds an implicit function that returns a `T` that
> it can call, .highlight[it will use its return value].


```scala
implicit val defaultDouble: Double = 3.0

implicit def getFloat(implicit d: Double): Float = d.toFloat

def printFloat(implicit f: Float): Unit = println(f)
```

```scala
printFloat
// 3.0
```

---

## Using `CellDecoder`, take 2

```scala
implicit def tupleDecoder(
    implicit da: CellDecoder[Int],
             db: CellDecoder[String]
  ) = RowDecoder.from[(Int, String)] {
  row => (
    da.decode(row(0)),
    db.decode(row(1))
  )
}
```

---

## Using `CellDecoder`, take 2

```scala
implicit `def` tupleDecoder(
    implicit da: CellDecoder[Int],
             db: CellDecoder[String]
  ) = RowDecoder.from[(Int, String)] {
  row => (
    da.decode(row(0)),
    db.decode(row(1))
  )
}
```

---

## Using `CellDecoder`, take 2

```scala
implicit def tupleDecoder(
    implicit `da: CellDecoder[Int]`,
             db: CellDecoder[String]
  ) = RowDecoder.from[(Int, String)] {
  row => (
    `da.decode(row(0))`,
    db.decode(row(1))
  )
}
```

---

## Using `CellDecoder`, take 2

```scala
implicit def tupleDecoder(
    implicit da: CellDecoder[Int],
             `db: CellDecoder[String]`
  ) = RowDecoder.from[(Int, String)] {
  row => (
    da.decode(row(0)),
    `db.decode(row(1))`
  )
}
```

---

## Using `CellDecoder`, take 2

```scala
implicit def tupleDecoder(
    `implicit` da: CellDecoder[Int],
             db: CellDecoder[String]
  ) = RowDecoder.from[(Int, String)] {
  row => (
    da.decode(row(0)),
    db.decode(row(1))
  )
}
```

---

## Using `CellDecoder`, take 2

```scala
implicit def tupleDecoder(
    implicit da: CellDecoder[`Int`],
             db: CellDecoder[`String`]
  ) = RowDecoder.from[`(Int, String)`] {
  row => (
    da.decode(row(0)),
    db.decode(row(1))
  )
}
```

---

## Using `CellDecoder`, take 3

```scala
implicit def tupleDecoder[A, B](
    implicit da: CellDecoder[A],
             db: CellDecoder[B]
  ) = RowDecoder.from[(A, B)] {
  row => (
    da.decode(row(0)),
    db.decode(row(1))
  )
}
```

---

## Using `CellDecoder`, take 3

```scala
implicit def tupleDecoder[`A, B`](
    implicit da: CellDecoder[`A`],
             db: CellDecoder[`B`]
  ) = RowDecoder.from[`(A, B)`] {
  row => (
    da.decode(row(0)),
    db.decode(row(1))
  )
}
```

---

## Using `CellDecoder`, take 3

```scala
implicit def tupleDecoder[A, B](
*   implicit da: CellDecoder[A],
*            db: CellDecoder[B]
  ) = RowDecoder.from[(A, B)] {
  row => (
    da.decode(row(0)),
    db.decode(row(1))
  )
}
```

---

## TODO TODO TODO

```scala
implicit def tupleDecoder[
  A: CellDecoder,
  B: CellDecoder
] = RowDecoder.from[(A, B)] {
  row => (
    implicitly[CellDecoder[A]].decode(row(0)),
    implicitly[CellDecoder[B]].decode(row(1))
  )
}
```

---

## TODO TODO TODO

```scala
implicit def tupleDecoder[
  `A: CellDecoder`,
  `B: CellDecoder`
] = RowDecoder.from[(A, B)] {
  row => (
    implicitly[CellDecoder[A]].decode(row(0)),
    implicitly[CellDecoder[B]].decode(row(1))
  )
}
```

---

## TODO TODO TODO

```scala
implicit def tupleDecoder[
  A: CellDecoder,
  B: CellDecoder
] = RowDecoder.from[(A, B)] {
  row => (
    `implicitly[CellDecoder[A]]`.decode(row(0)),
    `implicitly[CellDecoder[B]]`.decode(row(1))
  )
}
```


---

## TODO TODO TODO

```scala
object CellDecoder {
  def from[T](
    f: Cell => T
  ) = new CellDecoder[T] {
    override def decode(cell: Cell) = f(cell)
  }

  def apply[T](implicit dt: CellDecoder[T]): CellDecoder[T] = dt
}
```

---

## TODO TODO TODO

```scala
object CellDecoder {
  def from[T](
    f: Cell => T
  ) = new CellDecoder[T] {
    override def decode(cell: Cell) = f(cell)
  }

  `def apply[T](implicit dt: CellDecoder[T]): CellDecoder[T] = dt`
}
```

---

## TODO TODO TODO

```scala
object CellDecoder {
  def from[T](
    f: Cell => T
  ) = new CellDecoder[T] {
    override def decode(cell: Cell) = f(cell)
  }

  def apply[T](`implicit dt: CellDecoder[T]`): CellDecoder[T] = dt
}
```

---

## TODO TODO TODO

```scala
object CellDecoder {
  def from[T](
    f: Cell => T
  ) = new CellDecoder[T] {
    override def decode(cell: Cell) = f(cell)
  }

  def apply[T](implicit dt: CellDecoder[T]): CellDecoder[T] = `dt`
}
```

---

## TODO TODO TODO

```scala
implicit def tupleDecoder[
  A: CellDecoder,
  B: CellDecoder
] = RowDecoder.from[(A, B)] {
  row => (
    CellDecoder[A].decode(row(0)),
    CellDecoder[B].decode(row(1))
  )
}
```

---

## TODO TODO TODO

```scala
implicit def tupleDecoder[
  A: CellDecoder,
  B: CellDecoder
] = RowDecoder.from[(A, B)] {
  row => (
    `CellDecoder[A]`.decode(row(0)),
    `CellDecoder[B]`.decode(row(1))
  )
}
```

---

## TODO TODO TODO

```scala
implicit def tupleDecoder[
  A: CellDecoder,
  B: CellDecoder
] = RowDecoder.from[(A, B)] {
  row => (
    `CellDecoder[A]`.decode(row(0)),
    CellDecoder[B].decode(row(1))
  )
}
```

---

## TODO TODO TODO

```scala
implicit def tupleDecoder[
  `A: CellDecoder`,
  B: CellDecoder
] = RowDecoder.from[(A, B)] {
  row => (
    CellDecoder[A].decode(row(0)),
    CellDecoder[B].decode(row(1))
  )
}
```


---

## Heterogenous types

```scala
val input = """1997,Ford
              |2000,Mercury"""
```

---

## TODO TODO TODO

```scala
decodeCsv[(Int, String)](input)
```

---

## TODO TODO TODO

```scala
decodeCsv[`(Int, String)`](input)
```

---

## TODO TODO TODO

```scala
decodeCsv[(Int, String)](input)`   `
```

---

## TODO TODO TODO

```scala
decodeCsv(input)(tupleDecoder[Int, String])
```

---

## TODO TODO TODO

```scala
decodeCsv(input)`(tupleDecoder[Int, String])`
```

---

## TODO TODO TODO

```scala
decodeCsv(input)(tupleDecoder[Int, String]`   `)
```

---

## TODO TODO TODO

```scala
decodeCsv(input)(tupleDecoder(intCellDecoder, stringCellDecoder))
```

---

## TODO TODO TODO

```scala
decodeCsv(input)(tupleDecoder`(intCellDecoder, stringCellDecoder)`)
```

---

## TODO TODO TODO

```scala
decodeCsv(input)(tupleDecoder(intCellDecoder, stringCellDecoder))
// res16: List[(Int, String)] = List((1997,Ford), (2000,Mercury))
```

---

## TODO TODO TODO

```scala
decodeCsv[(Int, String)](input)
// res17: List[(Int, String)] = List((1997,Ford), (2000,Mercury))
```

---

## Optional cells

```scala
val input = """1997,Ford
              |,Mercury"""
```

---

## Optional cells

```scala
implicit def optionCellDecoder[A: CellDecoder] =
  CellDecoder.from[Option[A]] {
    case "" => None
    case s  => Some(CellDecoder[A].decode(s))
  }
```

---

## Optional cells

```scala
implicit def optionCellDecoder[`A: CellDecoder`] =
  CellDecoder.from[Option[A]] {
    case "" => None
    case s  => Some(CellDecoder[A].decode(s))
  }
```

---

## Optional cells

```scala
&#x200B;`implicit` def optionCellDecoder[A: CellDecoder] =
  `CellDecoder`.from[`Option[A]`] {
    case "" => None
    case s  => Some(CellDecoder[A].decode(s))
  }
```

---

## Optional cells

```scala
implicit def optionCellDecoder[A: CellDecoder] =
  CellDecoder.from[Option[A]] {
    case `""` => `None`
    case s  => Some(CellDecoder[A].decode(s))
  }
```

---

## Optional cells

```scala
implicit def optionCellDecoder[A: CellDecoder] =
  CellDecoder.from[Option[A]] {
    case "" => None
    case `s`  => `Some(CellDecoder[A].decode(s))`
  }
```

---

## Optional cells

```scala
decodeCsv[(Option[Int], String)](input)
// res18: List[(Option[Int], String)] = List((Some(1997),Ford), (None,Mercury))
```

---

## Cells with multiple types

```scala
val input = """1997,Ford
              |true,Mercury"""
```

---

## Cells with multiple types

```scala
implicit def eitherCellDecoder[A: CellDecoder, B: CellDecoder] =
  CellDecoder.from[Either[A, B]] { cell =>
    try { Left(CellDecoder[A].decode(cell)) }
    catch { case _: Throwable => Right(CellDecoder[B].decode(cell)) }
  }
```

---

## Cells with multiple types

```scala
decodeCsv[(Either[Int, Boolean], String)](input)
// res19: List[(Either[Int,Boolean], String)] = List((Left(1997),Ford), (Right(true),Mercury))
```

---

## Complex compositions

```scala
val input = """1997,Ford
              |false,Mercury
              |,Chevy"""
```

---

## Complex compositions

```scala
decodeCsv[(Option[Either[Int, Boolean]], String)](input)
// res20: List[(Option[Either[Int,Boolean]], String)] = List((Some(Left(1997)),Ford), (Some(Right(false)),Mercury), (None,Chevy))
```

---

## Collections of values

```scala
val input = """1,2,3
              |4,5,6"""
```

---

## Collections of values

```scala
import scala.collection.generic.CanBuildFrom

implicit def cbfDecoder[A: CellDecoder, F[_]](
    implicit cbf: CanBuildFrom[Nothing, A, F[A]]
  ) =  RowDecoder.from[F[A]] { row =>
    row.foldLeft(cbf.apply()) { (out, s) =>
      out += CellDecoder[A].decode(s)
    }.result()
  }
```

---

## Collections of values

```scala
decodeCsv[List[Int]](input)
// res21: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6))

decodeCsv[Vector[Int]](input)
// res22: List[Vector[Int]] = List(Vector(1, 2, 3), Vector(4, 5, 6))

decodeCsv[Array[Int]](input)
// res23: List[Array[Int]] = List(Array(1, 2, 3), Array(4, 5, 6))
```

---

## Case classes

We *could* write a `RowDecoder[A]` instance for any case class `A`…

--

… but I'd have to use [shapeless](http://shapeless.io), and this would turn into a different talk entirely.

---

class: center, middle

# In closing

---

## If you only remember 1 slide...

Type classes:
* are great at adding new behaviours to existing types
* compose implicitly, without having to write any type specific code

---
class: center, middle

# Questions?

Nicolas Rinaudo • [@NicolasRinaudo] • [Besedo]

[@NicolasRinaudo]:https://twitter.com/NicolasRinaudo
[Besedo]:https://twitter.com/besedo_official

    </textarea>
    <script src="js/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
        var slideshow = remark.create({
          highlightStyle: 'github',
          highlightSpans: true,
          highlightLines: true
      });
    </script>
  </body>
</html>
