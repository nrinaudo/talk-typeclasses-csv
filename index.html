<!DOCTYPE html>
<html>
    <head>
        <title>Type classes from the ground up</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <link rel="stylesheet" type="text/css" href="css/style.css"/>
    </head>
    <body>
        <textarea id="source">
class: center, middle

# Type classes from the ground up

Nicolas Rinaudo • [@NicolasRinaudo] • [Besedo]

---

class: center, middle

# Parsing CSV

---

## CSV data

```csv
1,2,3
4,5,6
7,8,9
```

```scala
type Cell = String
type Row  = List[Cell]
type Csv  = List[Row]
```

---

## CSV data

```csv
&#x200B;`1,2,3`
&#x200B;`4,5,6`
&#x200B;`7,8,9`
```

```scala
type Cell = String
type Row  = List[Cell]
*type Csv  = List[Row]
```

---

## CSV data

```csv
&#x200B;`1`,`2`,`3`
4,5,6
7,8,9
```

```scala
type Cell = String
*type Row  = List[Cell]
type Csv  = List[Row]
```

---

## CSV data

```csv
&#x200B;`1`,2,3
4,5,6
7,8,9
```

```scala
*type Cell = String
type Row  = List[Cell]
type Csv  = List[Row]
```

---

## Parsing CSV

```csv
1,2,3
4,5,6
7,8,9
```

```scala
def parseCsv(data: String) = ???
```

---

## Parsing CSV

```csv
*1,2,3
*4,5,6
*7,8,9
```

```scala
def parseCsv(`data: String`) = ???
```

---

## Parsing CSV

```csv
&#x200B;`1,2,3`
&#x200B;`4,5,6`
&#x200B;`7,8,9`
```

```scala
def parseCsv(data: String) =
  data.
    split("\n").toList
```

---

## Parsing CSV

```csv
&#x200B;`1,2,3`
&#x200B;`4,5,6`
&#x200B;`7,8,9`
```

```scala
def parseCsv(data: String) =
  data.
    `split("\n")`.toList
```

---

## Parsing CSV

```csv
&#x200B;`1`,`2`,`3`
&#x200B;`4`,`5`,`6`
&#x200B;`7`,`8`,`9`
```

```scala
def parseCsv(data: String): Csv =
  data.
    split("\n").toList.
    map(_.split(",").toList)
```

---

## Parsing CSV

```csv
&#x200B;`1`,`2`,`3`
&#x200B;`4`,`5`,`6`
&#x200B;`7`,`8`,`9`
```

```scala
def parseCsv(data: String): Csv =
  data.
    split("\n").toList.
    map(_.`split(",")`.toList)
```

---

## Parsing CSV

```csv
&#x200B;`1`,`2`,`3`
&#x200B;`4`,`5`,`6`
&#x200B;`7`,`8`,`9`
```

```scala
def parseCsv(data: String): `Csv` =
  data.
    split("\n").toList.
    map(_.split(",").toList)
```

---

## Parsing CSV

```scala
val input = "1,2,3\n4,5,6\n7,8,9"
// input: String =
// 1,2,3
// 4,5,6
// 7,8,9
```

--

```scala
parseCsv(input)
// res0: Csv = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

---

class: center, middle

# Decoding CSV

---

## Decoding to `Int`

```csv
1,2,3
4,5,6
7,8,9
```

```scala
parseCsv(input).
  map(_.map(_.toInt))
```

---

## Decoding to `Int`

```csv
&#x200B;`1`,`2`,`3`
&#x200B;`4`,`5`,`6`
&#x200B;`7`,`8`,`9`
```

```scala
&#x200B;`parseCsv(input)`.
  map(_.map(_.toInt))
```

---

## Decoding to `Int`

```csv
&#x200B;`1`,`2`,`3`
4,5,6
7,8,9
```

```scala
parseCsv(input).
  `map`(_.map(_.toInt))
```

---

## Decoding to `Int`

```csv
&#x200B;`1`,2,3
4,5,6
7,8,9
```

```scala
parseCsv(input).
  map(_.`map`(_.toInt))
```

---

## Decoding to `Int`

```csv
&#x200B;`1`,2,3
4,5,6
7,8,9
```

```scala
parseCsv(input).
  map(_.map(_.`toInt`))
```

---

## Decoding to `Int`

```csv
1,2,3
4,5,6
7,8,9
```

```scala
parseCsv(input).
  map(_.map(_.toInt))
// res1: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input: String
): List[List[Int]] =
  parseCsv(input).
    map(_.map(_.toInt))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  `input: String`
): List[List[Int]] =
  parseCsv(input).
    map(_.map(_.toInt))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input: String
): `List[List[Int]]` =
  parseCsv(input).
    map(_.map(_.toInt))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input: String
): List[List[Int]] =
* parseCsv(input).
*   map(_.map(_.toInt))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input: String
): List[List[Int]] =
  parseCsv(input).
    map(_.map(`_.toInt`))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input     : String,
  decodeCell: Cell => Int
): List[List[Int]] =
  parseCsv(input).
    map(_.map(decodeCell))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input     : String,
  `decodeCell: Cell => Int`
): List[List[Int]] =
  parseCsv(input).
    map(_.map(decodeCell))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input     : String,
  decodeCell: Cell => Int
): List[List[Int]] =
  parseCsv(input).
    map(_.map(`decodeCell`))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input     : String,
  decodeCell: Cell => `Int`
): List[List[`Int`]] =
  parseCsv(input).
    map(_.map(decodeCell))
```

---

## Generic decoding

```scala
def decodeCsv[A](
  input     : String,
  decodeCell: Cell => A
): List[List[A]] =
  parseCsv(input).
    map(_.map(decodeCell))
```

---

## Generic decoding

```scala
def decodeCsv[`A`](
  input     : String,
  decodeCell: Cell => `A`
): List[List[`A`]] =
  parseCsv(input).
    map(_.map(decodeCell))
```

---

## Generic decoding

```scala
decodeCsv(input, _.toInt)
```

---

## Generic decoding

```scala
decodeCsv(input, `_.toInt`)
```

---

## Generic decoding

```scala
decodeCsv(input, _.toInt)
// res2: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

---

## Generic decoding

```scala
decodeCsv(input, _.toFloat)
```

---

## Generic decoding

```scala
decodeCsv(input, `_.toFloat`)
```

---

## Generic decoding

```scala
decodeCsv(input, _.toFloat)
// res3: List[List[Float]] = List(List(1.0, 2.0, 3.0), List(4.0, 5.0, 6.0), List(7.0, 8.0, 9.0))
```

---

## Implicit resolution

> When a function expects a parameter of type `T` _and_ that parameter is marked as `implicit` _and_ there exists a
> value of type `T` marked as `implicit` in scope, then the compiler will use that value if the parameter is unspecified.

```scala
implicit val defaultInt: Int = 2

def printInt(implicit i: Int): Unit = println(i)
```

```scala
printInt
```

---

## Implicit resolution

> When a function expects a .highlight[parameter of type `T`] _and_ that parameter is marked as `implicit` _and_ there exists a
> value of type `T` marked as `implicit` in scope, then the compiler will use that value if the parameter is unspecified.

```scala
implicit val defaultInt: Int = 2

def printInt(implicit `i: Int`): Unit = println(i)
```

```scala
printInt
```

---

## Implicit resolution

> When a function expects a parameter of type `T` _and_ that parameter is .highlight[marked as `implicit`] _and_ there exists a
> value of type `T` marked as `implicit` in scope, then the compiler will use that value if the parameter is unspecified.

```scala
implicit val defaultInt: Int = 2

def printInt(`implicit` i: Int): Unit = println(i)
```

```scala
printInt
```

---

## Implicit resolution

> When a function expects a parameter of type `T` _and_ that parameter is marked as `implicit` _and_ there exists a
> .highlight[value of type `T`] marked as `implicit` in scope, then the compiler will use that value if the parameter is unspecified.

```scala
implicit `val defaultInt: Int` = 2

def printInt(implicit i: Int): Unit = println(i)
```

```scala
printInt
```

---

## Implicit resolution

> When a function expects a parameter of type `T` _and_ that parameter is marked as `implicit` _and_ there exists a
> value of type `T` marked as .highlight[`implicit`] in scope, then the compiler will use that value if the parameter is unspecified.

```scala
&#x200B;`implicit` val defaultInt: Int = 2

def printInt(implicit i: Int): Unit = println(i)
```

```scala
printInt
```

---

## Implicit resolution

> When a function expects a parameter of type `T` _and_ that parameter is marked as `implicit` _and_ there exists a
> value of type `T` marked as `implicit` in scope, then the compiler will use that value .highlight[if the parameter is unspecified].

```scala
implicit val defaultInt: Int = 2

def printInt(implicit i: Int): Unit = println(i)
```

```scala
printInt`            `
```

---

## Implicit resolution

> When a function expects a parameter of type `T` _and_ that parameter is marked as `implicit` _and_ there exists a
> value of type `T` marked as `implicit` in scope, then .highlight[the compiler will use that value] if the parameter is unspecified.

```scala
implicit val defaultInt: Int = 2

def printInt(implicit i: Int): Unit = println(i)
```

```scala
printInt`(defaultInt)`
```

---

## Implicit resolution

> When a function expects a parameter of type `T` _and_ that parameter is marked as `implicit` _and_ there exists a
> value of type `T` marked as `implicit` in scope, then the compiler will use that value if the parameter is unspecified.

```scala
implicit val defaultInt: Int = 2

def printInt(implicit i: Int): Unit = println(i)
```

```scala
printInt
// 2
```

---

## Decoding CSV with implicits

```scala
def decodeCsv[A]
  (input: String)
  (implicit decodeCell: Cell => A)
 : List[List[A]] =
  parseCsv(input).
    map(_.map(decodeCell))

```

---

## Decoding CSV with implicits

```scala
def decodeCsv[A]
  (input: String)
  (`implicit decodeCell: Cell => A`)
 : List[List[A]] =
  parseCsv(input).
    map(_.map(decodeCell))
```

---

## Decoding CSV with implicits

```scala
implicit val strToInt: Cell => Int =
  Integer.parseInt
```

---

## Decoding CSV with implicits

```scala
&#x200B;`implicit` val strToInt: `Cell => Int` =
  Integer.parseInt
```

---

## Decoding CSV with implicits

```scala
decodeCsv[Int](input)
```

---

## Decoding CSV with implicits

```scala
decodeCsv[`Int`](input)
```

---

## Decoding CSV with implicits

```scala
decodeCsv[Int](input)`    `
```

---

## Decoding CSV with implicits

```scala
decodeCsv[Int](input)
// res6: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

---

## The dangers of implicits

> When the compiler finds a type `S` where it expects a type `T`, but there exists an implicit `S => T`
> in scope, it will be applied silently.

```scala
implicit val strToInt: String => Int =
  Integer.parseInt

def add1(i: Int): Int = i + 1
```

```scala
add1("123")
```


---

## The dangers of implicits

> When .highlight[the compiler finds a type `S`] where it expects a type `T`, but there exists an implicit `S => T`
> in scope, it will be applied silently.

```scala
implicit val strToInt: String => Int =
  Integer.parseInt

def add1(i: Int): Int = i + 1
```

```scala
add1(`"123"`)
```

---

## The dangers of implicits

> When the compiler finds a type `S` where .highlight[it expects a type `T`], but there exists an implicit `S => T`
> in scope, it will be applied silently.

```scala
implicit val strToInt: String => Int =
  Integer.parseInt

def add1(`i: Int`): Int = i + 1
```

```scala
add1("123")
```

---

## The dangers of implicits

> When the compiler finds a type `S` where it expects a type `T`, but .highlight[there exists an implicit `S => T`]
> in scope, it will be applied silently.

```scala
&#x200B;`implicit` val strToInt: `String => Int` =
  Integer.parseInt

def add1(i: Int): Int = i + 1
```

```scala
add1("123")
```

---

## The dangers of implicits

> When the compiler finds a type `S` where it expects a type `T`, but there exists an implicit `S => T`
> in scope, .highlight[it will be applied silently].

```scala
implicit val strToInt: String => Int =
  Integer.parseInt

def add1(i: Int): Int = i + 1
```

```scala
add1(`strToInt("123")`)
```

---

## The dangers of implicits

> When the compiler finds a type `S` where it expects a type `T`, but there exists an implicit `S => T`
> in scope, it will be applied silently.

```scala
implicit val strToInt: String => Int =
  Integer.parseInt

def add1(i: Int): Int = i + 1
```

```scala
add1("123")
// res8: Int = 124
```

---

## Using a decoder type

```scala
trait CellDecoder[T] {
  def decode(cell: Cell): T
}
```

---

## Using a decoder type

```scala
trait `CellDecoder[T]` {
  def decode(cell: Cell): T
}
```

---

## Using a decoder type

```scala
trait CellDecoder[T] {
  `def decode(cell: Cell): T`
}
```

---

## Using a decoder type

```scala
trait CellDecoder[T] {
  def decode(`cell: Cell`): T
}
```

---

## Using a decoder type

```scala
trait CellDecoder[T] {
  def decode(cell: Cell): `T`
}
```

---

## Using a decoder type

```scala
object CellDecoder {
  def from[T](
    f: Cell => T
  ) = new CellDecoder[T] {
    override def decode(cell: Cell) = f(cell)
  }
}
```

---

## Using a decoder type

```scala
&#x200B;`object CellDecoder` {
  def from[T](
    f: Cell => T
  ) = new CellDecoder[T] {
    override def decode(cell: Cell) = f(cell)
  }
}
```

---

## Using a decoder type

```scala
object CellDecoder {
  `def from[T]`(
    f: Cell => T
  ) = `new CellDecoder[T]` {
    override def decode(cell: Cell) = f(cell)
  }
}
```

---

## Using a decoder type

```scala
object CellDecoder {
  def from[T](
    `f: Cell => T`
  ) = new CellDecoder[T] {
    override `def decode(cell: Cell) = f(cell)`
  }
}
```

---

## Using a decoder type

```scala
implicit val intCellDecoder =
  CellDecoder.from(_.toInt)
```

---

## Using a decoder type

```scala
implicit val intCellDecoder =
  CellDecoder.from(`_.toInt`)
```

---

## Type class backed decoder

```scala
def decodeCsv[A]
  (input: String)
  (implicit da: CellDecoder[A])
 : List[List[A]] =
  parseCsv(input).
    map(_.map(da.decode))
```

---

## Type class backed decoder

```scala
def decodeCsv[A]
  (input: String)
  (implicit `da: CellDecoder[A]`)
 : List[List[A]] =
  parseCsv(input).
    map(_.map(da.decode))
```

---

## Type class backed decoder

```scala
def decodeCsv[A]
  (input: String)
  (implicit da: CellDecoder[A])
 : List[List[A]] =
  parseCsv(input).
    map(_.map(`da.decode`))
```


---

## Type class backed decoder

```scala
decodeCsv[Int](input)
```

---

## Type class backed decoder

```scala
decodeCsv[`Int`](input)
```

---

## Type class backed decoder

```scala
decodeCsv[Int](input)`   `
```

---

## Type class backed decoder

```scala
decodeCsv[Int](input)
// res10: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```


---

## Enhancement without inheritance!

Important realisation: _we've added a new behaviour to `Int`, even though it's `final`_.

--

Think about implementing the same with subtyping:

* create a `Decodable` interface.

--

* have `Int` implement `Decodable`.

--

* but `Int` is final...

--

* create... `WrappedInt` that implements `Decodable` and proxies all calls to `Int`?

--

* 😱

---

class: center, middle

# Combining type classe instances

---

## Heterogenous types

`decodeCsv` can decode our input. But what about:

```scala
val input = "1,Nicolas\n2,Jessica\n3,Matt"
// input: String =
// 1,Nicolas
// 2,Jessica
// 3,Matt
```

--

This could be decoded as a `(Int, String)`.

Problem: we only know how to decode rows of homogenous types.

---

## `RowDecoder` type class

We need a decoder type class for rows:

```scala
trait RowDecoder[T] {
  def decode(cells: List[String]): T
}
```

--

`decodeCsv` now looks like:

```scala
def decodeCsv[A](input: String)
                (implicit da: RowDecoder[A]): List[A] =
  parseCsv(input).
    map(da.decode)
```

---

## First, a bit of plumbing

Let's make instance creation less of a pain:

```scala
def cellDecoder[A](f: String => A) = new CellDecoder[A] {
  override def decode(cell: String) = f(cell)
}

def rowDecoder[A](f: List[String] => A) = new RowDecoder[A] {
  override def decode(cells: List[String]) = f(cells)
}

```

--

Also, create a bunch of useful `CellDecoder` instances:

```scala
implicit val intCellDecoder     = cellDecoder(_.toInt)
implicit val floatCellDecoder   = cellDecoder(_.toFloat)
implicit val stringCellDecoder  = cellDecoder(identity)
implicit val booleanCellDecoder = cellDecoder(_.toBoolean)
```

???

Default instances should be declared in the companion object, it's just not very convenient here.

---

## First attempt at decoding tuples

```scala
implicit val tupleDecoder: RowDecoder[(Int, String)] =
  rowDecoder(cells => (cells(0).toInt, cells(1)))
```

--

This works:

```scala
decodeCsv[(Int, String)](input)
// res11: List[(Int, String)] = List((1,Nicolas), (2,Jessica), (3,Matt))
```

--

Disapointing, though: decoding of individual cells is hard-coded.

Didn't we just write a mechanism for that?

---

## Using `CellDecoder`, take 1

Naive implementation:

```scala
implicit val tupleDecoder: RowDecoder[(Int, String)] =
  rowDecoder { cells => (
    intCellDecoder.decode(cells(0)),
    stringCellDecoder.decode(cells(1))
  )}
```

--

The decoder instances are hard-coded - always a sign that things can be made more generic.

---

## Implicit resolution revisited

> When the compiler looks for an implicit value of type `T` and finds an implicit function that returns a `T` that
> it can call, it will use its return value.

---

## Implicit resolution revisited

```scala
implicit val defaultDouble: Double = 3.0

implicit def getFloat(implicit d: Double): Float = d.toFloat

def printFloat(implicit f: Float): Unit = println(f)
```

--

Running `printFloat` without a parameter:

```scala
printFloat
// 3.0
```

--

Strictly equivalent to:

```scala
printFloat(getFloat(defaultDouble))
```

???

This can be a bit hard to follow, go through the steps:
- `printFloat` looks for an implicit `Float`
- `getFloat` might produce an implicit `Float`, but needs an implicit `Double`
- `double` is an implicit `Double`

---

## Using `CellDecoder`, take 2

Better implementation:

```scala
implicit def tupleDecoder(
    implicit di: CellDecoder[Int],
             ds: CellDecoder[String]
  ): RowDecoder[(Int, String)] =
  rowDecoder(cells => (di.decode(cells(0)), ds.decode(cells(1))))
```

--

This produces the desired result:

```scala
decodeCsv[(Int, String)](input)
// res14: List[(Int, String)] = List((1,Nicolas), (2,Jessica), (3,Matt))
```

--

`Int` and `String` are hard-coded, but not used - a strong hint that they should be type parameters.

---

## Using `CellDecoder`, take 3

Fully generic implementation:

```scala
implicit def tupleDecoder[A, B](
    implicit da: CellDecoder[A],
             db: CellDecoder[B]
  ): RowDecoder[(A, B)] =
  rowDecoder(cells => (da.decode(cells(0)), db.decode(cells(1))))
```

???

You can think of the implicit parameters as constraints on `A` and `B` - `decode` accepts any two types `A` and `B`
that fulfill the constraint of being decodable as cells.

--

Take a minute to let that sink in:

_We've written an instance of `RowDecoder[(A, B)]` for all `A` and `B` that have a `CellDecoder` instance_.

---

## Implicit resolution steps

```scala
decodeCsv[(Float, String)](input)
// res15: List[(Float, String)] = List((1.0,Nicolas), (2.0,Jessica), (3.0,Matt))
```

We need an implicit `RowDecoder[(Float, String)]`.

--

`tupleDecoder` might produce one:

```scala
decodeCsv(input)(tupleDecoder[Float, String])
```

We now need implicit `CellDecoder[Float]` and `CellDecoder[String]` instances.

--

`floatCellDecoder` and `stringCellDecoder` work:

```scala
decodeCsv(input)(tupleDecoder(floatCellDecoder, stringCellDecoder))
```

???

Interesting how the type parameters move to the right and disappear as the compiler uses more and more specialised
instances.

---

## Optional cells

Sometimes, CSV cells are absent or empty:

```scala
val input = "1,Nicolas\n,Jessica\n3,Matt"
// input: String =
// 1,Nicolas
// ,Jessica
// 3,Matt
```

---

## Optional cells

This is what `Option` is made for.

```scala
implicit def optionCellDecoder[A](
    implicit da: CellDecoder[A]
  ): CellDecoder[Option[A]] = cellDecoder {
  case "" => None
  case s  => Some(da.decode(s))
}
```

---

## Optional cells

This yields the expected result:

```scala
decodeCsv[(Option[Int], String)](input)
// res18: List[(Option[Int], String)] = List((Some(1),Nicolas), (None,Jessica), (Some(3),Matt))
```

--

_We've written an instance of `CellDecoder[Option[A]]` for all `A` that have a `CellDecoder` instance._

---

## Cells with multiple types

"Sometimes", CSV data is messy:

```scala
val input = "1,Nicolas\ntrue,Jessica"
// input: String =
// 1,Nicolas
// true,Jessica
```

---

## Cells with multiple types

We have `Either` to represent these cases:

```scala
implicit def eitherCellDecoder[A, B](implicit
    da: CellDecoder[A],
    db: CellDecoder[B]
  ): CellDecoder[Either[A, B]] = cellDecoder { cell =>
    try { Left(da.decode(cell)) }
    catch { case _: Throwable => Right(db.decode(cell)) }
  }
```

---

## Cells with multiple types

This yields the expected result:

```scala
decodeCsv[(Either[Int, Boolean], String)](input)
// res19: List[(Either[Int,Boolean], String)] = List((Left(1),Nicolas), (Right(true),Jessica))
```

--

_We've written an instance of `CellDecoder[Either[A, B]]` for all `A` and `B` that have a `CellDecoder` instance._

---

## Complex compositions

```scala
val input = "1,Nicolas\nfalse,Jessica\n,Matt"
// input: String =
// 1,Nicolas
// false,Jessica
// ,Matt
```

The first column looks like an `Option[Either[Int, Boolean]]`.

--

We already have `Either` and `Option` instances, so we get this for free:

```scala
decodeCsv[(Option[Either[Int, Boolean]], String)](input)
// res20: List[(Option[Either[Int,Boolean]], String)] = List((Some(Left(1)),Nicolas), (Some(Right(false)),Jessica), (None,Matt))
```

---

## Collections of values

We have lost the ability to decode a row as `List[Int]` on the way:

```scala
val input = "1,2,3\n4,5,6"
// input: String =
// 1,2,3
// 4,5,6
```

---

## Collections of values

"Easily" fixed (warning -
uses [`CanBuildFrom`](http://www.scala-lang.org/api/2.11.8/#scala.collection.generic.CanBuildFrom)):

```scala
import scala.collection.generic.CanBuildFrom

implicit def cbfDecoder[A, F[_]](
    implicit da: CellDecoder[A],
             cbf: CanBuildFrom[Nothing, A, F[A]]
  ): RowDecoder[F[A]] =
  rowDecoder(_.foldLeft(cbf.apply()) { (out, s) =>
    out += da.decode(s)
  }.result())
```

???

Ignore the `CanBuildFrom` type - it's needlessly complicated and out of scope.

---

## Collections of values

This yields the expected result:

```scala
decodeCsv[List[Int]](input)
// res21: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6))

decodeCsv[Vector[Int]](input)
// res22: List[Vector[Int]] = List(Vector(1, 2, 3), Vector(4, 5, 6))

decodeCsv[Array[Int]](input)
// res23: List[Array[Int]] = List(Array(1, 2, 3), Array(4, 5, 6))
```

--

_We've written an instance of `RowDecoder[F[A]]` for any collection `F` and any `A` that has a `CellDecoder` instance._

---

## Case classes

We *could* write a `RowDecoder[A]` instance for any case class `A`…

--

… but I'd have to use [shapeless](http://shapeless.io), and this would turn into a different talk entirely.

---

class: center, middle

# Tips & Tricks

---

## Cell decoding helper

Having a method to decode a string into an arbitrary type would be helpful, if only for REPL debugging:

```scala
def decodeCell[A](cell: String)(implicit da: CellDecoder[A]): A =
  da.decode(cell)
```

--

We can now do:

```scala
decodeCell[Int]("123")
// res24: Int = 123
```

---

## Context bounds

_Context bounds_ offer a more pleasant syntax:

```scala
def decodeCell[A: CellDecoder](cell: String): A =
  implicitly[CellDecoder[A]].decode(cell)
```

--

`decodeCell`'s type signature is now clearer and easier to read.

--

`decodeCell`'s _body_, on the other hand...

---

## Instance summoning methods

It's good practice to provide an instance summoning `apply` method in the companion object:

```scala
object CellDecoder {
  def apply[A](implicit da: CellDecoder[A]): CellDecoder[A] = da
}
```

--

We can now rewrite `decodeCell`:

```scala
def decodeCell[A: CellDecoder](cell: String): A =
  CellDecoder[A].decode(cell)
```

--

⚠️️ Note that this has a cost - the implicit instance is resolved through a method call.

[Erik Osheim](https://twitter.com/d6/)'s [imp](https://github.com/non/imp) addresses this issue elegantly.

---

## Syntax / operators

We can go even further by enhancing `String` through implicit conversion:

```scala
case class CellDecoderOps(cell: String) {
  def decodeCell[A: CellDecoder]: A = CellDecoder[A].decode(cell)
}

implicit val toCellDecoderOps: String => CellDecoderOps =
  CellDecoderOps.apply
```

--

This lets us write:

```scala
"123".decodeCell[Int]
// res25: Int = 123
```

---

## Syntax / operators (improved)

_Implicit classes_ are syntactic sugar for this:

```scala
implicit class CellDecoderOps(val cell: String) {
  def decodeCell[A: CellDecoder]: A = CellDecoder[A].decode(cell)
}
```

--

⚠️️ Operators have a cost - boxing and unboxing of values. They can be offset by:
- making the implicit class a value class (`extends AnyVal`).
- Using [Erik Osheim](https://twitter.com/d6/)'s [machinist](https://github.com/typelevel/machinist).

--

⚠️️ Implicit classes can be tricky - in particular, they suffer from surprising name conflicts.

???
A safer, boilerplate-heavy approach to implicit classes is the `ToXxxOps` pattern.

---

class: center, middle

# Wrapping things up

---

## Conclusions

Type classes:
* are great at adding new behaviours to existing types

```scala
implicit val uuidDecoder = cellDecoder(java.util.UUID.fromString)
```

--

* compose implicitly, without having to write any type specific code

```scala
implicitly[RowDecoder[List[Either[Int, Option[Either[Boolean, java.util.UUID]]]]]]
// res26: RowDecoder[List[Either[Int,Option[Either[Boolean,java.util.UUID]]]]] = $anon$1@58594987
```

---
class: center, middle

# Questions?

Nicolas Rinaudo • [@NicolasRinaudo] • [Besedo]

[@NicolasRinaudo]:https://twitter.com/NicolasRinaudo
[Besedo]:https://twitter.com/besedo_official

    </textarea>
    <script src="js/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
        var slideshow = remark.create({
          highlightStyle: 'github',
          highlightSpans: true,
          highlightLines: true
      });
    </script>
  </body>
</html>
