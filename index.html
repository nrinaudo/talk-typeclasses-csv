<!DOCTYPE html>
<html>
    <head>
        <title>Type classes from the ground up</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <link rel="stylesheet" type="text/css" href="css/style.css"/>
    </head>
    <body>
        <textarea id="source">
class: center, middle

# Type classes from the ground up

Nicolas Rinaudo • [@NicolasRinaudo] • [Besedo]

---

class: center, middle

# Parsing CSV

---

## CSV data

```csv
1,2,3
4,5,6
7,8,9
```

```scala
type Cell = String
type Row  = List[Cell]
type Csv  = List[Row]
```

---

## CSV data

```csv
&#x200B;`1,2,3`
&#x200B;`4,5,6`
&#x200B;`7,8,9`
```

```scala
type Cell = String
type Row  = List[Cell]
*type Csv  = List[Row]
```

---

## CSV data

```csv
&#x200B;`1`,`2`,`3`
4,5,6
7,8,9
```

```scala
type Cell = String
*type Row  = List[Cell]
type Csv  = List[Row]
```

---

## CSV data

```csv
&#x200B;`1`,2,3
4,5,6
7,8,9
```

```scala
*type Cell = String
type Row  = List[Cell]
type Csv  = List[Row]
```

---

## Parsing CSV

```csv
1,2,3
4,5,6
7,8,9
```

```scala
def parseCsv(data: String) = ???
```

---

## Parsing CSV

```csv
*1,2,3
*4,5,6
*7,8,9
```

```scala
def parseCsv(`data: String`) = ???
```

---

## Parsing CSV

```csv
&#x200B;`1,2,3`
&#x200B;`4,5,6`
&#x200B;`7,8,9`
```

```scala
def parseCsv(data: String) =
  data.
    split("\n").toList
```

---

## Parsing CSV

```csv
&#x200B;`1,2,3`
&#x200B;`4,5,6`
&#x200B;`7,8,9`
```

```scala
def parseCsv(data: String) =
  data.
    `split("\n")`.toList
```

---

## Parsing CSV

```csv
&#x200B;`1`,`2`,`3`
&#x200B;`4`,`5`,`6`
&#x200B;`7`,`8`,`9`
```

```scala
def parseCsv(data: String): Csv =
  data.
    split("\n").toList.
    map(_.split(",").toList)
```

---

## Parsing CSV

```csv
&#x200B;`1`,`2`,`3`
&#x200B;`4`,`5`,`6`
&#x200B;`7`,`8`,`9`
```

```scala
def parseCsv(data: String): Csv =
  data.
    split("\n").toList.
    map(_.`split(",")`.toList)
```

---

## Parsing CSV

```csv
&#x200B;`1`,`2`,`3`
&#x200B;`4`,`5`,`6`
&#x200B;`7`,`8`,`9`
```

```scala
def parseCsv(data: String): `Csv` =
  data.
    split("\n").toList.
    map(_.split(",").toList)
```

---

## Parsing CSV

```scala
val input = """1,2,3
              |4,5,6
              |7,8,9"""
```

--

```scala
parseCsv(input)
// res0: Csv = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

---

class: center, middle

# Decoding CSV

---

## Decoding to `Int`

```csv
1,2,3
4,5,6
7,8,9
```

```scala
parseCsv(input).
  map(_.map(_.toInt))
```

---

## Decoding to `Int`

```csv
&#x200B;`1`,`2`,`3`
&#x200B;`4`,`5`,`6`
&#x200B;`7`,`8`,`9`
```

```scala
&#x200B;`parseCsv(input)`.
  map(_.map(_.toInt))
```

---

## Decoding to `Int`

```csv
&#x200B;`1`,`2`,`3`
4,5,6
7,8,9
```

```scala
parseCsv(input).
  `map`(_.map(_.toInt))
```

---

## Decoding to `Int`

```csv
&#x200B;`1`,2,3
4,5,6
7,8,9
```

```scala
parseCsv(input).
  map(_.`map`(_.toInt))
```

---

## Decoding to `Int`

```csv
&#x200B;`1`,2,3
4,5,6
7,8,9
```

```scala
parseCsv(input).
  map(_.map(_.`toInt`))
```

---

## Decoding to `Int`

```csv
1,2,3
4,5,6
7,8,9
```

```scala
parseCsv(input).
  map(_.map(_.toInt))
// res1: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input: String
): List[List[Int]] =
  parseCsv(input).
    map(_.map(_.toInt))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  `input: String`
): List[List[Int]] =
  parseCsv(input).
    map(_.map(_.toInt))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input: String
): `List[List[Int]]` =
  parseCsv(input).
    map(_.map(_.toInt))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input: String
): List[List[Int]] =
* parseCsv(input).
*   map(_.map(_.toInt))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input: String
): List[List[Int]] =
  parseCsv(input).
    map(_.map(`_.toInt`))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input     : String,
  decodeCell: Cell => Int
): List[List[Int]] =
  parseCsv(input).
    map(_.map(decodeCell))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input     : String,
  `decodeCell: Cell => Int`
): List[List[Int]] =
  parseCsv(input).
    map(_.map(decodeCell))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input     : String,
  decodeCell: Cell => Int
): List[List[Int]] =
  parseCsv(input).
    map(_.map(`decodeCell`))
```

---

## Decoding to `Int`

```scala
def decodeCsv(
  input     : String,
  decodeCell: Cell => `Int`
): List[List[`Int`]] =
  parseCsv(input).
    map(_.map(decodeCell))
```

---

## Generic decoding

```scala
def decodeCsv[A](
  input     : String,
  decodeCell: Cell => A
): List[List[A]] =
  parseCsv(input).
    map(_.map(decodeCell))
```

---

## Generic decoding

```scala
def decodeCsv[`A`](
  input     : String,
  decodeCell: Cell => `A`
): List[List[`A`]] =
  parseCsv(input).
    map(_.map(decodeCell))
```

---

## Generic decoding

```scala
decodeCsv(input, _.toInt)
```

---

## Generic decoding

```scala
decodeCsv(input, `_.toInt`)
```

---

## Generic decoding

```scala
decodeCsv(input, _.toInt)
// res2: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

---

## Generic decoding

```scala
decodeCsv(input, _.toFloat)
```

---

## Generic decoding

```scala
decodeCsv(input, `_.toFloat`)
```

---

## Generic decoding

```scala
decodeCsv(input, _.toFloat)
// res3: List[List[Float]] = List(List(1.0, 2.0, 3.0), List(4.0, 5.0, 6.0), List(7.0, 8.0, 9.0))
```

---

## Implicit resolution

> When a function expects a parameter of type `A` _and_ that parameter is marked as `implicit` _and_ there exists a
> value of type `A` marked as `implicit` in scope, then the compiler will use that value if the parameter is unspecified.

```scala
implicit val defaultInt: Int = 2

def printInt(implicit i: Int): Unit = println(i)
```

```scala
printInt
```

---

## Implicit resolution

> When .highlight[a function expects a parameter of type `A`] _and_ that parameter is marked as `implicit` _and_ there exists a
> value of type `A` marked as `implicit` in scope, then the compiler will use that value if the parameter is unspecified.

```scala
implicit val defaultInt: Int = 2

def printInt(implicit `i: Int`): Unit = println(i)
```

```scala
printInt
```

---

## Implicit resolution

> When a function expects a parameter of type `A` _and_ that parameter is .highlight[marked as `implicit`] _and_ there exists a
> value of type `A` marked as `implicit` in scope, then the compiler will use that value if the parameter is unspecified.

```scala
implicit val defaultInt: Int = 2

def printInt(`implicit` i: Int): Unit = println(i)
```

```scala
printInt
```

---

## Implicit resolution

> When a function expects a parameter of type `A` _and_ that parameter is marked as `implicit` _and_ there exists a
> .highlight[value of type `A`] marked as `implicit` in scope, then the compiler will use that value if the parameter is unspecified.

```scala
implicit `val defaultInt: Int` = 2

def printInt(implicit i: Int): Unit = println(i)
```

```scala
printInt
```

---

## Implicit resolution

> When a function expects a parameter of type `A` _and_ that parameter is marked as `implicit` _and_ there exists a
> value of type `A` marked as .highlight[`implicit`] in scope, then the compiler will use that value if the parameter is unspecified.

```scala
&#x200B;`implicit` val defaultInt: Int = 2

def printInt(implicit i: Int): Unit = println(i)
```

```scala
printInt
```

---

## Implicit resolution

> When a function expects a parameter of type `A` _and_ that parameter is marked as `implicit` _and_ there exists a
> value of type `A` marked as `implicit` in scope, then the compiler will use that value .highlight[if the parameter is unspecified].

```scala
implicit val defaultInt: Int = 2

def printInt(implicit i: Int): Unit = println(i)
```

```scala
printInt`            `
```

---

## Implicit resolution

> When a function expects a parameter of type `A` _and_ that parameter is marked as `implicit` _and_ there exists a
> value of type `A` marked as `implicit` in scope, then .highlight[the compiler will use that value] if the parameter is unspecified.

```scala
implicit val defaultInt: Int = 2

def printInt(implicit i: Int): Unit = println(i)
```

```scala
printInt`(defaultInt)`
```

---

## Implicit resolution

> When a function expects a parameter of type `A` _and_ that parameter is marked as `implicit` _and_ there exists a
> value of type `A` marked as `implicit` in scope, then the compiler will use that value if the parameter is unspecified.

```scala
implicit val defaultInt: Int = 2

def printInt(implicit i: Int): Unit = println(i)
```

```scala
printInt
// 2
```

---

## Decoding with implicits

```scala
def decodeCsv[A]
  (input: String)
  (implicit decodeCell: Cell => A)
 : List[List[A]] =
  parseCsv(input).
    map(_.map(decodeCell))

```

---

## Decoding with implicits

```scala
def decodeCsv[A]
  (input: String)
  (`implicit decodeCell: Cell => A`)
 : List[List[A]] =
  parseCsv(input).
    map(_.map(decodeCell))
```

---

## Decoding with implicits

```scala
implicit val strToInt: Cell => Int =
  Integer.parseInt
```

---

## Decoding with implicits

```scala
&#x200B;`implicit` val strToInt: `Cell => Int` =
  Integer.parseInt
```

---

## Decoding with implicits

```scala
decodeCsv[Int](input)
```

---

## Decoding with implicits

```scala
decodeCsv[`Int`](input)
```

---

## Decoding with implicits

```scala
decodeCsv[Int](input)`    `
```

---

## Decoding with implicits

```scala
decodeCsv[Int](input)
// res6: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

---

## The dangers of implicits

> When the compiler finds a type `S` where it expects a type `A`, but there exists an implicit `S => A`
> in scope, it will be applied silently.

```scala
implicit val strToInt: String => Int =
  Integer.parseInt

def add1(i: Int): Int = i + 1
```

```scala
add1("123")
```

---

## The dangers of implicits

> When .highlight[the compiler finds a type `A`] where it expects a type `B`, but there exists an implicit `A => B`
> in scope, it will be applied silently.

```scala
implicit val strToInt: String => Int =
  Integer.parseInt

def add1(i: Int): Int = i + 1
```

```scala
add1(`"123"`)
```

---

## The dangers of implicits

> When the compiler finds a type `A` where .highlight[it expects a type `B`], but there exists an implicit `A => B`
> in scope, it will be applied silently.

```scala
implicit val strToInt: String => Int =
  Integer.parseInt

def add1(`i: Int`): Int = i + 1
```

```scala
add1("123")
```

---

## The dangers of implicits

> When the compiler finds a type `A` where it expects a type `B`, but .highlight[there exists an implicit `A => B`]
> in scope, it will be applied silently.

```scala
&#x200B;`implicit` val strToInt: `String => Int` =
  Integer.parseInt

def add1(i: Int): Int = i + 1
```

```scala
add1("123")
```

---

## The dangers of implicits

> When the compiler finds a type `A` where it expects a type `B`, but there exists an implicit `A => B`
> in scope, .highlight[it will be applied silently].

```scala
implicit val strToInt: String => Int =
  Integer.parseInt

def add1(i: Int): Int = i + 1
```

```scala
add1(`strToInt("123")`)
```

---

## The dangers of implicits

> When the compiler finds a type `A` where it expects a type `B`, but there exists an implicit `A => B`
> in scope, it will be applied silently.

```scala
implicit val strToInt: String => Int =
  Integer.parseInt

def add1(i: Int): Int = i + 1
```

```scala
add1("123")
// res8: Int = 124
```

---

## Decoder type

```scala
trait CellDecoder[A] {
  def decode(cell: Cell): A
}
```

---

## Decoder type

```scala
trait `CellDecoder[A]` {
  def decode(cell: Cell): A
}
```

---

## Decoder type

```scala
trait CellDecoder[A] {
  `def decode(cell: Cell): A`
}
```

---

## Decoder type

```scala
trait CellDecoder[A] {
  def decode(`cell: Cell`): A
}
```

---

## Decoder type

```scala
trait CellDecoder[A] {
  def decode(cell: Cell): `A`
}
```

---

## Decoder type

```scala
object CellDecoder {
  def from[A](
    f: Cell => A
  ) = new CellDecoder[A] {
    override def decode(cell: Cell) = f(cell)
  }
}
```

---

## Decoder type

```scala
&#x200B;`object CellDecoder` {
  def from[A](
    f: Cell => A
  ) = new CellDecoder[A] {
    override def decode(cell: Cell) = f(cell)
  }
}
```

---

## Decoder type

```scala
object CellDecoder {
  `def from[A]`(
    f: Cell => A
  ) = `new CellDecoder[A]` {
    override def decode(cell: Cell) = f(cell)
  }
}
```

---

## Decoder type

```scala
object CellDecoder {
  def from[A](
    `f: Cell => A`
  ) = new CellDecoder[A] {
    override `def decode(cell: Cell) = f(cell)`
  }
}
```

---

## Decoder type

```scala
implicit val intCellDecoder: CellDecoder[Int] =
  CellDecoder.from(_.toInt)

implicit val floatCellDecoder: CellDecoder[Float] =
  CellDecoder.from(_.toFloat)

implicit val stringCellDecoder: CellDecoder[String] =
  CellDecoder.from(identity)

implicit val booleanCellDecoder: CellDecoder[Boolean] =
  CellDecoder.from(_.toBoolean)
```

---

## Decoder type

```scala
implicit val intCellDecoder: `CellDecoder[Int]` =
  CellDecoder.from(`_.toInt`)

implicit val floatCellDecoder: CellDecoder[Float] =
  CellDecoder.from(_.toFloat)

implicit val stringCellDecoder: CellDecoder[String] =
  CellDecoder.from(identity)

implicit val booleanCellDecoder: CellDecoder[Boolean] =
  CellDecoder.from(_.toBoolean)
```

---

## Decoder type

```scala
implicit val intCellDecoder: CellDecoder[Int] =
  CellDecoder.from(_.toInt)

implicit val floatCellDecoder: `CellDecoder[Float]` =
  CellDecoder.from(`_.toFloat`)

implicit val stringCellDecoder: CellDecoder[String] =
  CellDecoder.from(identity)

implicit val booleanCellDecoder: CellDecoder[Boolean] =
  CellDecoder.from(_.toBoolean)
```

---

## Decoder type

```scala
implicit val intCellDecoder: CellDecoder[Int] =
  CellDecoder.from(_.toInt)

implicit val floatCellDecoder: CellDecoder[Float] =
  CellDecoder.from(_.toFloat)

implicit val stringCellDecoder: `CellDecoder[String]` =
  CellDecoder.from(`identity`)

implicit val booleanCellDecoder: CellDecoder[Boolean] =
  CellDecoder.from(_.toBoolean)
```

---

## Decoder type

```scala
implicit val intCellDecoder: CellDecoder[Int] =
  CellDecoder.from(_.toInt)

implicit val floatCellDecoder: CellDecoder[Float] =
  CellDecoder.from(_.toFloat)

implicit val stringCellDecoder: CellDecoder[String] =
  CellDecoder.from(identity)

implicit val booleanCellDecoder: `CellDecoder[Boolean]` =
  CellDecoder.from(`_.toBoolean`)
```

---

## Implicit decoder

```scala
def decodeCsv[A]
  (input: String)
  (implicit da: CellDecoder[A])
 : List[List[A]] =
  parseCsv(input).
    map(_.map(da.decode))
```

---

## Implicit decoder

```scala
def decodeCsv[A]
  (input: String)
  (implicit `da: CellDecoder[A]`)
 : List[List[A]] =
  parseCsv(input).
    map(_.map(da.decode))
```

---

## Implicit decoder

```scala
def decodeCsv[A]
  (input: String)
  (implicit da: CellDecoder[A])
 : List[List[A]] =
  parseCsv(input).
    map(_.map(`da.decode`))
```

---

## Implicit decoder

```scala
decodeCsv[Int](input)
```

---

## Implicit decoder

```scala
decodeCsv[`Int`](input)
```

---

## Implicit decoder

```scala
decodeCsv[Int](input)`   `
```

---

## Implicit decoder

```scala
decodeCsv[Int](input)
// res10: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

---

## Key takeaways

--
We have made `decodeCsv` polymorphic by using:

--
* parametric polymorphism.

--
* implicit resolution.

--

`CellDecoder` is known as a type class.

---

class: center, middle

# Implicit type class composition

---

## Heterogenous types

```csv
1997,Ford
2000,Mercury
```

---

## Heterogenous types

```csv
&#x200B;`1997`,Ford
&#x200B;`2000`,Mercury
```

---

## Heterogenous types

```csv
1997,`Ford`
2000,`Mercury`
```

---

## `RowDecoder` type class

```scala
trait RowDecoder[A] {
  def decode(row: Row): A
}
```

---

## `RowDecoder` type class

```scala
trait `RowDecoder[A]` {
  def decode(row: Row): A
}
```

---

## `RowDecoder` type class

```scala
trait RowDecoder[A] {
  `def decode(row: Row): A`
}
```

---

## `RowDecoder` type class

```scala
trait RowDecoder[A] {
  def decode(`row: Row`): A
}
```

---

## `RowDecoder` type class

```scala
trait RowDecoder[A] {
  def decode(row: Row): `A`
}
```

---

## `RowDecoder` type class

```scala
object RowDecoder {
  def from[A](
    f: Row => A
  ) = new RowDecoder[A] {
    override def decode(row: Row) = f(row)
  }
}
```

---

## `RowDecoder` type class

```scala
&#x200B;`object RowDecoder` {
  def from[A](
    f: Row => A
  ) = new RowDecoder[A] {
    override def decode(row: Row) = f(row)
  }
}
```

---

## `RowDecoder` type class

```scala
object RowDecoder {
  `def from[A]`(
    f: Row => A
  ) = `new RowDecoder[A]` {
    override def decode(row: Row) = f(row)
  }
}
```

---

## `RowDecoder` type class

```scala
object RowDecoder {
  def from[A](
    `f: Row => A`
  ) = new RowDecoder[A] {
    override `def decode(row: Row) = f(row)`
  }
}
```

---

## `RowDecoder` type class

```scala
def decodeCsv[A](input: String)
                (implicit da: RowDecoder[A]): List[A] =
  parseCsv(input).
    map(da.decode)
```

---

## `RowDecoder` type class

```scala
def decodeCsv[A](input: String)
                (implicit `da: RowDecoder[A]`): List[A] =
  parseCsv(input).
    map(da.decode)
```

---

## `RowDecoder` type class

```scala
def decodeCsv[A](input: String)
                (implicit da: RowDecoder[A]): List[A] =
  parseCsv(input).
    `map(da.decode)`
```

---

## `RowDecoder` type class

```scala
def decodeCsv[A](input: String)
                (implicit da: RowDecoder[A]): `List[A]` =
  parseCsv(input).
    map(da.decode)
```

---

## `(Int, String)` decoder

```scala
implicit val tupleDecoder = RowDecoder.from[(Int, String)] {
  row => (
    row(0).toInt,
    row(1)
  )
}
```

---

## `(Int, String)` decoder

```scala
&#x200B;`implicit` val tupleDecoder = `RowDecoder`.from[`(Int, String)`] {
  row => (
    row(0).toInt,
    row(1)
  )
}
```

---

## `(Int, String)` decoder

```scala
implicit val tupleDecoder = RowDecoder.from[(Int, String)] {
  `row` => (
    row(0).toInt,
    row(1)
  )
}
```

---

## `(Int, String)` decoder

```scala
implicit val tupleDecoder = RowDecoder.from[(Int, String)] {
  row => (
    `row(0).toInt`,
    row(1)
  )
}
```

---

## `(Int, String)` decoder

```scala
implicit val tupleDecoder = RowDecoder.from[(Int, String)] {
  row => (
    row(0).toInt,
    `row(1)`
  )
}
```

---

## `(Int, String)` decoder

```scala
implicit val tupleDecoder = RowDecoder.from[(Int, String)] {
  row => `(`
    row(0).toInt,
    row(1)
  `)`
}
```

---

## `(Int, String)` decoder

```scala
implicit val tupleDecoder = RowDecoder.from[(Int, String)] {
  row => (
    `row(0).toInt`,
    `row(1)`
  )
}
```

---

## `(Int, String)` decoder

```scala
implicit val tupleDecoder = RowDecoder.from[(Int, String)] {
  row => (
    intCellDecoder.decode(row(0)),
    stringCellDecoder.decode(row(1))
  )
}
```

---

## `(Int, String)` decoder

```scala
implicit val tupleDecoder = RowDecoder.from[(Int, String)] {
  row => (
    `intCellDecoder.decode(row(0))`,
    `stringCellDecoder.decode(row(1))`
  )
}
```

---

## `(Int, String)` decoder

```scala
implicit `val` tupleDecoder = RowDecoder.from[(Int, String)] {
  row => (
    intCellDecoder.decode(row(0)),
    stringCellDecoder.decode(row(1))
  )
}
```

---

## Implicit resolution revisited

> When the compiler looks for an implicit value of type `A` and finds an implicit function that returns a `A` that
> it can call, it will use its return value.

```scala
implicit val defaultDouble: Double = 3.0

implicit def getFloat(implicit d: Double): Float = d.toFloat

def printFloat(implicit f: Float): Unit = println(f)
```

```scala
printFloat
```

---

## Implicit resolution revisited

> When the .highlight[compiler looks for an implicit value of type `A`] and finds an implicit function that returns a `A` that
> it can call, it will use its return value.

```scala
implicit val defaultDouble: Double = 3.0

implicit def getFloat(implicit d: Double): Float = d.toFloat

def printFloat(implicit f: Float): Unit = println(f)
```

```scala
printFloat`   `
```

---

## Implicit resolution revisited

> When the .highlight[compiler looks for an implicit value of type `A`] and finds an implicit function that returns a `A` that
> it can call, it will use its return value.

```scala
implicit val defaultDouble: Double = 3.0

implicit def getFloat(implicit d: Double): Float = d.toFloat

def printFloat(`implicit f: Float`): Unit = println(f)
```

```scala
printFloat
```

---

## Implicit resolution revisited

> When the compiler looks for an implicit value of type `A` and .highlight[finds an implicit function that returns a `A`] that
> it can call, it will use its return value.

```scala
implicit val defaultDouble: Double = 3.0

&#x200B;`implicit def getFloat`(implicit d: Double): `Float` = d.toFloat

def printFloat(implicit f: Float): Unit = println(f)
```

```scala
printFloat
```

---

## Implicit resolution revisited

> When the compiler looks for an implicit value of type `A` and finds an implicit function that returns a `A` that
> .highlight[it can call], it will use its return value.

```scala
implicit val defaultDouble: Double = 3.0

implicit def getFloat(`implicit d: Double`): Float = d.toFloat

def printFloat(implicit f: Float): Unit = println(f)
```

```scala
printFloat
```

---

## Implicit resolution revisited

> When the compiler looks for an implicit value of type `A` and finds an implicit function that returns a `A` that
> .highlight[it can call], it will use its return value.

```scala
&#x200B;`implicit val defaultDouble: Double` = 3.0

implicit def getFloat(implicit d: Double): Float = d.toFloat

def printFloat(implicit f: Float): Unit = println(f)
```

```scala
printFloat
```

---

## Implicit resolution revisited

> When the compiler looks for an implicit value of type `A` and finds an implicit function that returns a `A` that
> it can call, .highlight[it will use its return value].

```scala
implicit val defaultDouble: Double = 3.0

implicit def getFloat(implicit d: Double): Float = d.toFloat

def printFloat(implicit f: Float): Unit = println(f)
```

```scala
printFloat`(getFloat)`
```

---

## Implicit resolution revisited

> When the compiler looks for an implicit value of type `A` and finds an implicit function that returns a `A` that
> it can call, .highlight[it will use its return value].

```scala
implicit val defaultDouble: Double = 3.0

implicit def getFloat(implicit d: Double): Float = d.toFloat

def printFloat(implicit f: Float): Unit = println(f)
```

```scala
printFloat`(getFloat(defaultDouble))`
```

---

## Implicit resolution revisited

> When the compiler looks for an implicit value of type `A` and finds an implicit function that returns a `A` that
> it can call, .highlight[it will use its return value].

```scala
implicit val defaultDouble: Double = 3.0

implicit def getFloat(implicit d: Double): Float = d.toFloat

def printFloat(implicit f: Float): Unit = println(f)
```

```scala
printFloat
// 3.0
```

---

## `(Int, String)` decoder

```scala
implicit def tupleDecoder(
    implicit da: CellDecoder[Int],
             db: CellDecoder[String]
  ) = RowDecoder.from[(Int, String)] {
  row => (
    da.decode(row(0)),
    db.decode(row(1))
  )
}
```

---

## `(Int, String)` decoder

```scala
implicit `def` tupleDecoder(
    implicit da: CellDecoder[Int],
             db: CellDecoder[String]
  ) = RowDecoder.from[(Int, String)] {
  row => (
    da.decode(row(0)),
    db.decode(row(1))
  )
}
```

---

## `(Int, String)` decoder

```scala
implicit def tupleDecoder(
    implicit `da: CellDecoder[Int]`,
             db: CellDecoder[String]
  ) = RowDecoder.from[(Int, String)] {
  row => (
    `da.decode(row(0))`,
    db.decode(row(1))
  )
}
```

---

## `(Int, String)` decoder

```scala
implicit def tupleDecoder(
    implicit da: CellDecoder[Int],
             `db: CellDecoder[String]`
  ) = RowDecoder.from[(Int, String)] {
  row => (
    da.decode(row(0)),
    `db.decode(row(1))`
  )
}
```

---

## `(Int, String)` decoder

```scala
implicit def tupleDecoder(
    `implicit` da: CellDecoder[Int],
             db: CellDecoder[String]
  ) = RowDecoder.from[(Int, String)] {
  row => (
    da.decode(row(0)),
    db.decode(row(1))
  )
}
```

---

## `(Int, String)` decoder

```scala
implicit def tupleDecoder(
    implicit da: CellDecoder[`Int`],
             db: CellDecoder[`String`]
  ) = RowDecoder.from[`(Int, String)`] {
  row => (
    da.decode(row(0)),
    db.decode(row(1))
  )
}
```

---

## `(A, B)` decoder

```scala
implicit def tupleDecoder[A, B](
    implicit da: CellDecoder[A],
             db: CellDecoder[B]
  ) = RowDecoder.from[(A, B)] {
  row => (
    da.decode(row(0)),
    db.decode(row(1))
  )
}
```

---

## `(A, B)` decoder

```scala
implicit def tupleDecoder[`A, B`](
    implicit da: CellDecoder[`A`],
             db: CellDecoder[`B`]
  ) = RowDecoder.from[`(A, B)`] {
  row => (
    da.decode(row(0)),
    db.decode(row(1))
  )
}
```

---

## `(A, B)` decoder

```scala
implicit def tupleDecoder[A, B](
    implicit da: `CellDecoder[A]`,
             db: CellDecoder[B]
  ) = RowDecoder.from[(A, B)] {
  row => (
    da.decode(row(0)),
    db.decode(row(1))
  )
}
```

---

## `(A, B)` decoder

```scala
implicit def tupleDecoder[A, B](
    implicit da: CellDecoder[A],
             db: `CellDecoder[B]`
  ) = RowDecoder.from[(A, B)] {
  row => (
    da.decode(row(0)),
    db.decode(row(1))
  )
}
```

---

## `(A, B)` decoder

```scala
implicit def tupleDecoder[A, B](
    implicit da: CellDecoder[A],
             db: CellDecoder[B]
  ) = `RowDecoder`.from[`(A, B)`] {
  row => (
    da.decode(row(0)),
    db.decode(row(1))
  )
}
```

---

## Heterogenous types

```scala
val input = """1997,Ford
              |2000,Mercury"""
```

---

## Heterogenous types

```scala
decodeCsv[(Int, String)](input)
```

---

## Heterogenous types

```scala
decodeCsv[`(Int, String)`](input)
```

---

## Heterogenous types

```scala
decodeCsv[(Int, String)](input)`   `
```

---

## Heterogenous types

```scala
decodeCsv(input)(tupleDecoder[Int, String])
```

---

## Heterogenous types

```scala
decodeCsv(input)`(tupleDecoder[Int, String])`
```

---

## Heterogenous types

```scala
decodeCsv(input)(tupleDecoder[Int, String]`   `)
```

---

## Heterogenous types

```scala
decodeCsv(input)(tupleDecoder(intCellDecoder, stringCellDecoder))
```

---

## Heterogenous types

```scala
decodeCsv(input)(tupleDecoder`(intCellDecoder, stringCellDecoder)`)
```

---

## Heterogenous types

```scala
decodeCsv[(Int, String)](input)
// res16: List[(Int, String)] = List((1997,Ford), (2000,Mercury))
```

---

## Heterogenous types

```scala
decodeCsv[(Float, String)](input)
```

---

## Heterogenous types

```scala
decodeCsv[(`Float`, String)](input)
```

---

## Heterogenous types

```scala
decodeCsv[(Float, String)](input)
// res18: List[(Float, String)] = List((1997.0,Ford), (2000.0,Mercury))
```

---

## Optional cells

```csv
1997,Ford
 ,Mercury
```

---

## Optional cells

```scala
&#x200B;`1997`,Ford
 ,Mercury
```

---

## Optional cells

```scala
1997,Ford
&#x200B;` `,Mercury
```

---

## Optional cells

```scala
implicit def optionCellDecoder[A](
  implicit da: CellDecoder[A]
) = CellDecoder.from[Option[A]] { cell =>
  if(cell.trim.isEmpty) None
  else                  Some(da.decode(cell))
}
```

---

## Optional cells

```scala
implicit def optionCellDecoder[`A`](
  `implicit` da: `CellDecoder[A]`
) = CellDecoder.from[Option[A]] { cell =>
  if(cell.trim.isEmpty) None
  else                  Some(da.decode(cell))
}
```

---

## Optional cells

```scala
&#x200B;`implicit` def optionCellDecoder[A](
  implicit da: CellDecoder[A]
) = `CellDecoder`.from[`Option[A]`] { cell =>
  if(cell.trim.isEmpty) None
  else                  Some(da.decode(cell))
}
```

---

## Optional cells

```scala
implicit def optionCellDecoder[A](
  implicit da: CellDecoder[A]
) = CellDecoder.from[Option[A]] { cell =>
  `if(cell.trim.isEmpty) None`
  else                  Some(da.decode(cell))
}
```

---

## Optional cells

```scala
implicit def optionCellDecoder[A](
  implicit da: CellDecoder[A]
) = CellDecoder.from[Option[A]] { cell =>
  if(cell.trim.isEmpty) None
  `else                  Some(da.decode(cell))`
}
```

---

## Optional cells

```scala
implicit def optionCellDecoder[A](
  implicit da: CellDecoder[A]
) = CellDecoder.from[Option[A]] { cell =>
  if(cell.trim.isEmpty) None
  else                  `Some(da.decode(cell))`
}
```

---

## Optional cells

```scala
implicit def optionCellDecoder[A](
  implicit da: CellDecoder[A]
) = CellDecoder.from[Option[A]] { cell =>
  if(cell.trim.isEmpty) None
  else                  Some(`da.decode(cell)`)
}
```

---

## Optional cells

```scala
val input = """1997,Ford
              | ,Mercury"""
```


---

## Optional cells

```scala
decodeCsv[(Option[Int], String)](input)
```

---

## Optional cells

```scala
decodeCsv[`(Option[Int], String)`](input)
```

---

## Optional cells

```scala
decodeCsv[(Option[Int], String)](input)`   `
```

---

## Optional cells

```scala
decodeCsv[(Option[Int], String)](input)
// res20: List[(Option[Int], String)] = List((Some(1997),Ford), (None,Mercury))
```

---

## Cells with multiple types

```csv
1997,Ford
true,Mercury
```

---

## Cells with multiple types

```csv
&#x200B;`1997`,Ford
true,Mercury
```

---

## Cells with multiple types

```csv
1997,Ford
&#x200B;`true`,Mercury
```

---

## Cells with multiple types

```scala
implicit def eitherCellDecoder[A, B](
  implicit da: CellDecoder[A],
           db: CellDecoder[B]
) = CellDecoder.from[Either[A, B]] { cell =>
    try { Left(da.decode(cell)) }
    catch {
      case _: Throwable => Right(db.decode(cell))
    }
  }
```

---

## Cells with multiple types

```scala
implicit def eitherCellDecoder[`A`, B](
  `implicit` da: `CellDecoder[A]`,
           db: CellDecoder[B]
) = CellDecoder.from[Either[A, B]] { cell =>
    try { Left(da.decode(cell)) }
    catch {
      case _: Throwable => Right(db.decode(cell))
    }
  }
```

---

## Cells with multiple types

```scala
implicit def eitherCellDecoder[A, `B`](
  `implicit` da: CellDecoder[A],
           db: `CellDecoder[B]`
) = CellDecoder.from[Either[A, B]] { cell =>
    try { Left(da.decode(cell)) }
    catch {
      case _: Throwable => Right(db.decode(cell))
    }
  }
```

---

## Cells with multiple types

```scala
&#x200B;`implicit` def eitherCellDecoder[A, B](
  implicit da: CellDecoder[A],
           db: CellDecoder[B]
) = `CellDecoder`.from[`Either[A, B]`] { cell =>
    try { Left(da.decode(cell)) }
    catch {
      case _: Throwable => Right(db.decode(cell))
    }
  }
```

---

## Cells with multiple types

```scala
implicit def eitherCellDecoder[A, B](
  implicit da: CellDecoder[A],
           db: CellDecoder[B]
) = CellDecoder.from[Either[A, B]] { cell =>
    try { `Left(da.decode(cell))` }
    catch {
      case _: Throwable => Right(db.decode(cell))
    }
  }
```

---

## Cells with multiple types

```scala
implicit def eitherCellDecoder[A, B](
  implicit da: CellDecoder[A],
           db: CellDecoder[B]
) = CellDecoder.from[Either[A, B]] { cell =>
    try { Left(da.decode(cell)) }
    catch {
      case _: Throwable => `Right(db.decode(cell))`
    }
  }
```

---

## Cells with multiple types


```scala
val input = """1997,Ford
              |true,Mercury"""
```


---

## Cells with multiple types

```scala
decodeCsv[(Either[Int, Boolean], String)](input)
```

---

## Cells with multiple types

```scala
decodeCsv[`(Either[Int, Boolean], String)`](input)
```

---

## Cells with multiple types

```scala
decodeCsv[(Either[Int, Boolean], String)](input)`   `
```

---

## Cells with multiple types

```scala
decodeCsv[(Either[Int, Boolean], String)](input)
// res22: List[(Either[Int,Boolean], String)] = List((Left(1997),Ford), (Right(true),Mercury))
```

---

## Complex compositions

```scala
val input = """1997,Ford
              |false,Mercury
              | ,Chevy"""
```

---

## Complex compositions

```scala
val input = """`1997`,Ford
              |`false`,Mercury
              |` `,Chevy"""
```

---

## Complex compositions

```scala
decodeCsv[(Option[Either[Int, Boolean]], String)](input)
```

---

## Complex compositions

```scala
decodeCsv[`(Option[Either[Int, Boolean]], String)`](input)
```

---

## Complex compositions

```scala
decodeCsv[(Option[Either[Int, Boolean]], String)](input)`   `
```

---

## Complex compositions

```scala
decodeCsv[(Option[Either[Int, Boolean]], String)](input)
// res24: List[(Option[Either[Int,Boolean]], String)] = List((Some(Left(1997)),Ford), (Some(Right(false)),Mercury), (None,Chevy))
```

---

## Collections of values

```csv
1,2,3
4,5,6
7,8,9"""
```

---

## Collections of values

```scala
import scala.collection.generic.CanBuildFrom

implicit def cbfDecoder[A, F[_]](
  implicit da: CellDecoder[A],
           cbf: CanBuildFrom[Nothing, A, F[A]]
) =  RowDecoder.from[F[A]] { row =>
  row.foldLeft(cbf.apply()) { (out, s) =>
    out += da.decode(s)
  }.result()
}
```

---

## Collections of values

```scala
import scala.collection.generic.CanBuildFrom

implicit def cbfDecoder[`A`, F[_]](
  `implicit` da: `CellDecoder[A]`,
           cbf: CanBuildFrom[Nothing, A, F[A]]
) =  RowDecoder.from[F[A]] { row =>
  row.foldLeft(cbf.apply()) { (out, s) =>
    out += da.decode(s)
  }.result()
}
```

---

## Collections of values

```scala
import scala.collection.generic.CanBuildFrom

implicit def cbfDecoder[A, `F[_]`](
  `implicit` da: CellDecoder[A],
           cbf: `CanBuildFrom`[Nothing, A, F[A]]
) =  RowDecoder.from[F[A]] { row =>
  row.foldLeft(cbf.apply()) { (out, s) =>
    out += da.decode(s)
  }.result()
}
```

---

## Collections of values

```scala
import scala.collection.generic.CanBuildFrom

implicit def cbfDecoder[A, F[_]](
  implicit da: CellDecoder[A],
           cbf: CanBuildFrom[Nothing, A, F[A]]
) =  `RowDecoder`.from[`F[A]`] { row =>
  row.foldLeft(cbf.apply()) { (out, s) =>
    out += da.decode(s)
  }.result()
}
```

---

## Collections of values

```scala
val input = """1,2,3
              |4,5,6
              |7,8,9"""
```

---

## Collections of values

```scala
decodeCsv[List[Int]](input)
```

---

## Collections of values

```scala
decodeCsv[`List[Int]`](input)
```

---

## Collections of values

```scala
decodeCsv[List[Int]](input)
```

---

## Collections of values

```scala
decodeCsv[List[Int]](input)
// res26: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

---

## Collections of values


```scala
decodeCsv[Vector[Int]](input)
```

---

## Collections of values


```scala
decodeCsv[`Vector[Int]`](input)
```

---

## Collections of values


```scala
decodeCsv[Vector[Int]](input)
// res28: List[Vector[Int]] = List(Vector(1, 2, 3), Vector(4, 5, 6), Vector(7, 8, 9))
```

---

## Key takeaways

--

Type classes compose implicitly to create complex instances.

---

class: center, middle

# In closing

---

## If you only remember 1 slide...

Type classes:
* are great at adding new behaviours to existing types
* compose implicitly, without having to write any type specific code

---
class: center, middle

# Questions?

Nicolas Rinaudo • [@NicolasRinaudo] • [Besedo]

[@NicolasRinaudo]:https://twitter.com/NicolasRinaudo
[Besedo]:https://twitter.com/besedo_official

    </textarea>
    <script src="js/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
        var slideshow = remark.create({
          highlightStyle: 'github',
          highlightSpans: true,
          highlightLines: true
      });
    </script>
  </body>
</html>
